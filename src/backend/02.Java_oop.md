
# Java面向对象

```java
/*
    @markdownname javaSE_oop
    @Auther d3Lap1ace
    @Time 2024/03/26:下午6:22
    @Version 1.0
                        From the Laplace of Demon 
**/
```



1. 面向对象 : 更侧重于对象使用的一种编程方式     **本质上是以类的方式组织代码 以对象的调用方法实现功能**
2. 面向过程 : 更侧重于编程过程书写的一种编程方式     (自个动手造轮子哦~)
# 面向对象编程三大特征

**封装性:  数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。防止该类的代码和数据被外部类定义的代码随机访问 防止注入**

**继承性:  **继承实现了 **IS-A** 关系  **子类继承父类完全还更强大。**

**多态性:**  **当作用在不同的对象时，会产生不同的结果**

```java
* 类 : 事物的描述
* 属性 : 描述事物的特征
* 方法 : 描述事物的行为动作
类是对象的模板，对象是类的实体
```

# 封装性

**防止该类的代码和数据被外部类定义的代码随机访问  通过private关键字修饰变量和方法, 只暴露对外的setter和getter方法 和 构造器 来实现对对象的属性的设定和获取.**

## 1. 访问权限修饰符

>  

```java
访问权限修饰符 :
public : 公共的   --> 整个模块下都可以访问
protected : 受保护的 -->  最大权限是 : 不同包有继承关系  
不写 : 默认的 --> 只能在同一个包下访问
private : 私有的 --> 只能在同一个类中访问

Java 不可以跨越模块访问成员 !!!
```
|  | 在本类中 | 在同一个包下 | 不同包下有继承关系 | 不同包无关类 |
| --- | --- | --- | --- | --- |
| **public** | √ | √ | √ | √ |
| **protected** | √ | √ | √ |  |
| **不写** | √ | √ |  |  |
| **private** | √ |  |  |  |


## 2. getter and setter方法

```java
当属性被私有修饰之后,还需要给属性提供公共的访问!! // 留接口 后门

getXxx 方法 -> 获取属性值的方法            //赋值
        返回值类型 : Xxx属性的类型
        形参列表 : 无形参的方法
            
setXxx方法 -> 设置该属性值的方法           //调用
        返回值类型 : void
        形参列表 : (Xxx属性的类型 变量名)
```





## 3. 变量访问的就近原则问题

```java
变量访问时有远近关系 :
	局部位置 比 成员位置 要近 !
        
变量访问的就近原则问题 : 当访问变量时, 变量会优先访问离自己最近的那个变量 !      
    
想要打破变量的就近访问问题 :
	打破局部位置变量的访问,强制访问本类成员位置上的变量 : this.变量名
```

### 3.1  this 关键字

```java
this 关键字 :   // 谁调用this就是谁  也是 当前对象的引用
    this.变量名 : 强制访问本类成员位置上的变量 -> 打破变量就近访问原则的
    this.方法名(实参) : 强制访问本类成员位置上的方法 -> 不会这样写 ! 因为不存在局部方法 ! 只要是在访问方法就一定访问的是 成员方法 -> 所以可以省略 this.
```



### 3.2 局部变量和成员变量的区别
| 区别 | 局部变量 | 成员变量 |
| --- | --- | --- |
| **作用域** | 其所在的方法内 | 整个类中有效 [全局] |
| **默认值** | 没有 | 有默认值 |
| **位置不同** | 方法内,方法的形参上 | 类中方法外 |
| **生命周期** | 随着方法的调用产生,随着方法的执行完毕死亡 | 随着对象的创建产生,随着对象的死亡而死亡 |
| **内存中的位置不同** | 栈内存中 | 堆内存中 |
| **在IDEA中的颜色不同** | 黑色 | 紫色 |


> 成员变量,成员方法 都 属于对象 !
>  
> 记忆技巧 :
>  
> 1. 因为在类中位置不同,所以导致作用域不同和在内存中的位置不同
> 2. 因为在内存中位置不同,所以导致默认值不同和生命周期不同
> 

> 如果变量,方法没有被使用时 : 颜色是灰的 !


## 4. 构造方法 [构造器]

```java
构造方法 : 虽然是方法,但是是特殊的方法 [和其他方法有多不一样的地方,但是本质上是方法]
    
方法 : 封装了特定功能的代码块
构造 : 构建 创造 
--> 用来构建和创造 "对象" 的方法   

        
构造方法的格式 : 
	//无参构造
	访问权限修饰符 类名(){
        //方法体;
    }

	//有参构造/带参构造
	访问权限修饰符 类名(形参列表){
        //方法体;
    }  
        
注意事项 :
	1. 构造方法是通过关键字 new 来调用的 !
    2. 构造方法的名字必须和类名 一模一样 ! -> 大小写都一样 //构造方法不遵循小驼峰式命名    
    3. 构造方法是没有 返回值类型 这个板块 ! 连 void 都不可以写 ! //因为调用完构造方法的结果一定是生成了一个此类对象  !    
    4. 如果在一个类中没有定义构造方法,JVM会赠送一个 默认的无参构造  
    5. 在一个类中是可以有多个构造方法的 -> 写无参构造, 写有参构造 !    //构造方法是可以重载的 !!
    6. 只要你在类中定义了构造,那么JVM默认赠送的构造方法就不送的了 !  
    7. 就算有构造方法 也不能省略 set 方法的编写 -> 因为 set方法可以修改对象的属性 , 而构造一旦new出来,一定生成了新的对象的!
```



### 4.1. 构造方法和普通方法的区别

编写代码的角度：声明格式、作用都不同。但是语法格式相似，调用方式相似通过：方法名(实参列表)。

字节码文件的角度：构造器会以`<init>()方法`的形态呈现，用以初始化对象。

### 4.2 类的构造器能不能调用这个类中的其他构造器?

能  this()和super()都是构造器，this()调用本类构造器，super()调用父类构造器

## 5. static  final  关键字
### 5.1 final

1. 数据

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

2. 方法

声明方法不能被子类重写。
private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

3. 类

声明类不允许被继承。
### 5.2 static
static 关键字的特点 :
1. 被static修饰的成员被所有对象所共享 -> 一变则都变
2. 被static修饰的成员不属于单个对象,而是属于类 -> 属于类
3. 被static修饰的成员可以直接使用类名调用 -> 类名调
4. 被static修饰的成员[类属性]随着类的加载而加载优先于对象 -> 随着类
**// 被static关键字修饰的成员 变成了 类  而不是 对象**



### 5.3 静态成员的访问问题
|  | 非静态成员变量静态成员的访问问题 | 非静态成员方法 | 静态成员变量 | 静态成员方法 |
| --- | --- | --- | --- | --- |
| **非静态成员方法** | √ | √ | √ | √ |
| **静态成员方法** | X | X | √ | √ |


### 5.2 静态的使用场景

静态的使用场景在定义工具类的时候,把工具类中所有的成员变量和成员方法全部用static修饰 -> 目的是为了更方便使用工具类的程序员调用工具类的方法 -> 可以不创建工具类的对象,直接使用工具类的类名调用类中的方法 !

工具类的定义步骤 :
1. 定义类 -> 类名 : XxxxUtils
2. 把类中无参构造用 private 修饰 并不提供任何其他构造方法 -> 目的: 不让使用工具类的程序员创建工具类的对象, 因为工具类中所有的成员变量和成员方法都用static修饰,可以使用类名调用
3. 把工具类中所有的 成员变量和成员方法都用 static 修饰
### **5.3 初始化顺序**
静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

# 继承性

在一个现有类的基础上通过**extends**关键字构建一个新类，子类可以拥有父类的**成员变量以及成员方法**（但是不一定能访问或调用，比如父类中private私有的成员变量以及方法不能访问和调用）。**继承的作用就是能提高代码的复用性。**它可以访问和使用父类中的非私有成员变量，以及重写父类中的非私有成员方法。

//  java是单一继承   c++是多个继承

## 1. 继承关系下成员变量访问问题

```java
继承关系下 , 成员变量的访问特点 :
        1. 在子类中访问父类成员:
            a. 私有的 -> 访问不了
            b. 不同名的 -> 直接访问
            c. 同名的 -> 就近原则
                this.num : 访问本类成员位置
                super.num : 访问本类父类成员位置

        2. 在父类中访问子类成员:
            a. 直接访问 : 访问不了 -> 父类不知道自己有哪些子类
            b. 创建子类对象 : 通过子类对象调用子类自己的成员变量

        3. 在第三方类中,创建子类对象访问父类成员
            a. 私有的 : 访问不了
            b. 不同名 : 子类对象直接访问
            c. 同名的 : 子类对象只能访问自己类中的同名变量,访问不了父类的同名变量 -> 就近原则

        4. 在第三方类中,创建父类对象访问子类成员 : 不可以   //不如直接创建子类对象  :D
            // 总结 : 成员方法的调用不遵循就近原则[没有就近原则],
           // 具体调用的的哪个方法需要看调用方法真实对象的类型 (看new谁)
```

### 1.1 继承关系下构造方法访问问题

```java
1. 子类对象要加载 优先加载父类对象 !
    
2. 调用其他构造方法的代码(super(),super(实参),this(),this(实参))必须是构造方法的第一句

3. 如果在构造方法内 调用了其他构造方法,那么默认赠送的 super() 就不送了 !

4. 子类构造方法中 必须有一个构造方法去 加载父类  !!
```

## 2. this 和 super 关键字

```java
实操层面 :
	super() : 调用本类父类的无参构造方法
    super(实参) : 调用本类父类的有参构造方法
    this() : 调用本类的无参构造方法
    this(实参) : 调用本类的有参构造方法

    this.变量名 : 访问本类的成员变量
    this.方法名() : 访问本类的无参方法
    this.方法名(实参) : 访问本类的有参方法
    super.变量名 : 访问本类父类的成员变量
    super.方法名() : 访问本类父类的无参成员方法
    super.方法名(实参) : 访问本类父类的有参成员方法
        
    this : 打破局部位置的访问就近原则 !
    super : 打破本类成员位置的访问就近原则 !    
---------------------------------------------------------
概念层面 : 
	this : 当前对象的引用 
        哪个对象启动含有this关键字的方法,那么方法内的this关键字就指向哪个对象 ! -> 对象照镜子
        
   super : 父类的
        super 关键字不指向父类对象 , 因为当子类对象创建时并没有生成一个具体的父类对象 !
```

## 3. ★方法的重写

```java
方法的重载 : Overload -> 调用的多,定义少
    1. 必须在同一个类中
    2. 必须方法名相同
    3. 形参列表必须不同 [数量,类型,类型顺序]
    4. 与 返回值类型 , 方法体 , 形参变量名 无关
    
方法的重写 : Override  -> 调用的多,定义的也多
    1. 必须有继承关系 / 实现关系 [两个方法不再同一个类中]
    2. 子类重写父类的方法 要求 : 子类方法的声明=父类方法的声明 一模一样 [99%情况]
    3. 方法体不一样 [子类覆盖父类的方法]    
    4. 子类重写方法的访问权限修饰符 >= 父类方法的访问权限修饰符
    5. 方法的返回值类型 : 
		a. void : 必须一样
        b. 基本数据类型 : 必须一样
        c. 引用数据类型 : 子类重写方法的返回值类型 必须是 父类方法返回值类型的 同类型或者子类型
            //假设父类是大 子类是小 --> 子类重写方法的返回值类型 <= 父类方法返回值类型的
     6. 子类重写方法抛出的受检异常不能大于等于父类方法抛出的异常.
注意事项 :
	1. 私有方法不存在重写概念
    2. static 修饰的方法 不存在重写概念  : 当方法被加上static关键字,那么方法就属于类了,而方法的重写时子类方法对父类方法的一种延续[覆盖],两个方法是关系的 ! 加上static让2个方法就没有了关系,各自属于各自的类 !
```

# 多态性

**当作用在不同的对象时，会产生不同的结果**     对象  进入 盲盒            XD

```java
/**
 * 父类和子类中的同名属性不具备多态性, 因为它们是共存关系.
 * 静态方法也不具备多态性, 因为它们不是覆盖关系, 是共存关系
 * 只有非静态方法(对象方法)具备多态性.
 *
 * 类中的真正成员(具有描述性) : 属性, 方法, 内部类
 * 伪成员 : 构造器, 语句块
 *
 * 多态本质: 把子类对象"当作"是父类对象.
 *
 */
```

## 1. 多态的前提条件

```java
	1. 必须有继承/实现关系  
    2. 必须有 父引用接收子类对象 / 子引用强制接收父引用 的操作
        父引用接收子类对象 : Fu fu = new Zi(); 
			//例如 : Human human = new Man();
			//例如 : Animal animal = new Dog(); 任意一只狗都是动物

	    子引用接收父引用 :  Zi zi = (Zi)fu; // 当fu真的是在接收一个子类对象时
	
	3. 子类重写父类中的方法 //不是多态的必要条件,但是有这件事情可以让父引用的方法调用出现动态绑定特性

			[错误] : Zi zi = new Fu(); // Dog dog = new Animal();  任意一只动物都是狗 ?
```

### 1.1 多态的向上转型和向下转型

```java
向上转型 : 由子类对象变成父类引用 
    Fu fu = new Zi(); //Animal animal = new Dog();

向下转型 : 由父引用变成子引用
    Zi zi = (Zi)fu; // Dog dog = (Dog)animal;

多态[继承/实现]的弊端 :
        父引用不能访问子类的特有成员 [成员变量/成员方法]

多态[继承/实现]的弊端的解决方案 : 向下转型
            
多态的弊端告诉我们 : 创建对象一定创建子类对象 ! 子类对象的功能最多 [父引用只能自己的不能访问子类特有的变量和方法]
```

### 1.2 向下转型的弊端

```java
向下转型的弊端 ClassCastException [类型转换异常] -> 向下转型出现了问题
    
向下转型由前提 : 对象的真实类型必须和你要转型的类型一致 !! //是狗才能转换成狗, 是猫才能转换成猫 不能瞎转 [狗转猫,猫转狗]    
    
如何解决向下转型的弊端 : 在向下转型之前,做对象的类型判断 ! //是猫转猫,是狗转狗
    if(父引用 instanceof 子类名){
        //能进来说明 : 前面的父引用的真实类型是 后方子类型的 !
    }
```

## 2. 多态的真实使用场景

```java
// n 代表 此父类型由多少种子类型
// 1 代表 父类型自己的对象 [有时候可能没有这个1 : 当父类型是接口 / 抽象类]
1. 把父类型作为方法的形参,那么启动方法时能传入的实参类型是 n + 1 种 
2. 把父类型作为方法的返回值类型,那么方法返回值的类型可以是 n + 1 种 
3. 把父类型作为容器[数组/集合]元素的数据类型 , 那么此容器内能存储的对象类型是 n + 1 种    
    
4. 在异常处理时, 抛出[throws]父类型异常,子类型异常一并抛出了!
5. 在异常处理时, 捕获[catch]父类型异常,子类型异常一并被捕获了!
```

## 3. 多态的本质

```java
多态的本质 : Java种的多态描述的是Java引用数据类型子父类[实现类/父接口]之间的类型转换问题!!!!!!!
    
基本数据类型中有 自动提升 和 强制类型转换 : 
	基本数据类型能有此特性的前提是 : 基本数据类型之间有大小关系 
        [byte,short,char < int < long < float < double]
    自动提升 : 大类型的变量接收小类型的值; //double num = 1;
	强制转换 : 小类型的变量强制接收大类型的值; // int i = (int)num;
		强转有弊端 : 精度损失 --> 能不强转就不强转 !
            
            
引用数据类型中有 向上转型 和 向下转型 : //前提 : 有继承/实现关系 -> 因为有了继承和实现才有了类和类,类和接口之间的大小关系
	子类型/实现类 < 父类型/父接口
    向上转型 : 父引用接收子类对象 // Fu fu = new Zi();
	向下转型 : 子引用接收父引用 // Zi zi = (Zi)fu;
        向下转型弊端 : fu[父引用]的真实类型必须是对应的子类型 --> 多态中的向下转型使用非常频繁 , 因为父引用不能访问子类的特有行为,想去访问子类特有行为必须把父引用变成子类型对象!!
```

# 抽象类和接口

## 1. 抽象类

**只要被 abstract 关键字修饰的类就是抽象类!   抽象类的存在就是为了封装抽象方法的!**

**//不能创建对象    **

**//在子类中重写抽象父类中所有的抽象方法**

> 为什么要有抽象类 : 抽象类作为父类,对子类行为的约束增强 ! [子类继承抽象父类必须重写父类中所有的抽象方法]


```java
抽象 : abstract
格式 :
	public abstract class 类名{ //抽象类
        //无方法体
    }
抽象类 : 抽象类中的成员

    1. 可以有抽象方法
    2. 可以有成员变量
    3. 可以有自定义常量
    4. 可以有构造方法
    5. 可以有非静态方法
    6. 可以有静态方法
    
abstract 关键字不可以和哪些关键字一起用 : 
	1. final
    2. static : 抽象[abstract]方法没有方法体,加上static后可以使用类名去启动 -> 矛盾的!
    3. private :  抽象[abstract]方法必须让子类重写,而私有修饰子类看不见 -> 矛盾的!
```

## 2.接口

> 接口 : 比抽象类更抽象的"类"叫接口
>  
> - 属性全是全局常量 public static final
> - 接口用于表达某种能力.或标准和规范.
> - 面向接口编程 : 把子类对象多态为接口类型的对象来使用.
> - 抽象方法
> - 默认方法
> - 静态方法
> - 私有方法


```java
接口 : 是Java引用数据类型中的一种 [类(class),数组(Array),接口(interface),枚举(enum),注解(@interface),记录(record)]
    
接口的定义格式 :
	public interface 接口名{
    }
```

## 3.★接口与抽象类的区别

**定义不同**   抽象类用`abstract`关键字声明只能被继承    接口是使用`interface`关键字声明只能被实现

**成员方法不同** 抽象类包含 抽象方法和非抽象方法  接口再jdk8之前只有抽象方法  jdk8之后新加了 默认方法  静态方法 和私有方法

**构造函数和成员的不同**   抽象类可以有构造函数 可以有成员变量  接口不能有构造函数   只能有静态修饰的final变量

## 3. final 关键字

宏定义!!!!!!!!

// 不能被继承 重写 abstract修饰

```java
final 关键字 : 最终的 a
    
1. 类 : 最终的类 -> 被 final 修饰的类 没有子类; -> 不能被继承
2. 成员变量 : 最终的成员变量 -> 被 final 修饰的成员变量 不能改变 -> 变成了常量 [自定义常量]
    自定义常量的标准编写格式 :
		public static final 数据类型 常量名 = 初始化值; //虽然它有默认值但是作为了常量必须由程序员赋予初始化值;
		自定义常量的标准命名方式 : 全部大写,多个单词之间使用 下划线 分隔
3. 成员方法 : 最终的成员方法 -> 被 final 修饰的方法不能被重写 
4. 局部变量 : 最终的局部变量 -> 被 final 修饰的局部变量 不能改变 -> 变成了 局部位置的常量   
5. 对象 :被final修饰的对象 地址不可改变 地址上的内容可以改变
```

# 代码块

> 1. 局部代码块 : 在方法内的大括号
> 2. 构造代码块 : 在成员位置的大括号
> 3. 静态代码块 : 在成员位置被static修饰的大括号


### 局部代码块

```java
局部代码块 : 在方法内的大括号 
    作用 : 控制局部变量的生命周期 [变量的作用域 : 在其定义的大括号内有效]
        
    方法(){
        {
            //局部代码块
            局部变量;
        }
        //上面的局部变量此时已经死亡
    }    

局部代码块现在使用非常非常非常少,因为内存的硬件水平已经很高了 !
```

### 构造代码块

```java
构造代码块 : 定义在成员位置的代码块 [全局代码块]
    
格式 :
	public class 类名{
        //成员位置
        {
            //构造代码块
            书写代码;
        }
    }

    构造代码块的执行时机 :
        每当有对象创建时,构造代码块就需要执行一次,优先于构造方法执行! //千万不要误解构造代码块的执行时机 : 随着对象的创建而执行 [有几个对象创建就执行几次构造代码块,优先于对象创建执行 !]

    作用 : 为对象创建做准备 [我们可以把对象创建之前需要做的准备工作写在构造代码块中]

    举例 : 构造代码块 -> 宫女,太监  对象-> 皇上
```

### 静态代码块

```java
静态代码块 : : 定义在成员位置且被static修饰的代码块 
    
格式 :
	public class 类名{
        //成员位置
        static{
            //静态代码块
            书写代码;
        }
    }  

    静态代码块的执行时机 : 随着类的加载而执行的,只执行一次 ! 优先于构造代码块,优先于构造方法 !

    静态代码块的作用 : 为类的加载做准备的代码可以写在 静态代码块中

    举例 : 静态代码块 --> 驱动[类的驱动]

    小技巧 : 当类中有静态代码块的时候,自定义常量定义时可以先定义后赋值, 后赋值 必须要在静态代码块里面赋值
```



# 内部类

> 内部类 : 定义在类中的类 !
>  
> 1. 成员内部类 : 定义在一个类成员位置的类
> 2. 静态成员内部类 : 定义在一个类成员位置且被static修饰的类
> 3. 局部内部类 : 定义在方法内的类 [了解]
> 4. 匿名内部类 : 接口/抽象父类的另一种使用形式 [重点]


## 1. 成员内部类

```java
/**
 * 内部类 :
 *      成员内部类 : 声明在类中方法外
 *              没有static修饰的 : 普通内部类
 *              有static修饰的 : 嵌套类
 *      局部内部类 : 声明在方法中
 *              普通局部内部类 :
 *              匿名内部类(最重要) : 主要用于配合接口
 */
```

```java
成员内部类 : 定义在一个类成员位置的类 叫成员内部类
    
格式 :
	class Outer{ //外部类
        //成员位置
        class Inner{ //成员内部类
            
        }
    }

    成员内部类的访问问题 :
        1. 在内部类中访问外部类成员 :
               a. 不同名 : 直接访问 [隐藏了 外部类类名.this.]
               b. 同名 : Outer.this.成员名称 -> 外部类类名.this.成员名称
               
        2. 在外部类中访问内部类成员 : 创建内部类对象
            
        3. 在第三方类中创建外部类对象访问内部类成员 : 弄不了, 外部类对象只能调用外部类自己的成员变量和成员方法
        
        4. 在第三方类中创建内部类对象访问外部类成员 : 弄不了, 内部类对象只能调用内部类自己的成员变量和成员方法
        
            在第三方类中创建内部类对象的公式 : Outer.Inner inner = new Outer().new Inner();
            --> 有了内部类对象,自然可以在第三方类中访问内部类成员
            
            
     使用场景 : 当一个类只为另一个类服务时,可以把第一个类定义在第二个类的内部 ! [A : 发动机  B: 汽车]
```

## 2. 静态成员内部类

```java
静态成员内部类 : 定义在一个类成员位置且被static修饰的类 叫静态成员内部类
    
格式 :
	class Outer{ //外部类
        //成员位置
        static class Inner{ //静态成员内部类
            //只有当类是成员内部类时 这个类才能被 static 修饰
        }
    }    

静态成员内部类比成员内部类用的多 !!! 
    
        1. 在内部类中访问外部类成员 : 不能直接访问的 [加载时机问题]
            解决方案 : 在内部类中创建外部类对象

        2. 在外部类中访问内部类成员 :  不能用Inner类名直接访问Inner的成员 [因为Inner的成员没有被static修饰 所以还是属于Inner对象的]
            解决方案 : 在外部类中创建内部类对象

        3. 在第三方类中创建外部类对象访问内部类成员 : 弄不了, 外部类对象只能调用外部类自己的成员变量和成员方法

        4. 在第三方类中创建内部类对象访问外部类成员 : 弄不了, 内部类对象只能调用内部类自己的成员变量和成员方法
               创建静态成员内部类对象 : Outer.Inner inner = new Outer.Inner();
               创建成员内部类对象 : Outer.Inner inner = new Outer().new Inner();
```

## 3. 局部内部类

```java
局部内部类 : 定义在方法内的类 叫局部内部类
    
格式 :
	class Outer{ //外部类
        外部类的方法(形参){
            //局部位置
            class Inner{ //局部内部类
                
            }
        }
    }


局部内部类何时使用 : 当一个类只为一个方法服务时,可以把这个类定义在这个方法内 //此情况非常非常非常少见
    
		1. 在内部类中访问外部类成员 :
            局部内部类所在方法 不可以是静态方法!
                a. 不同名 : 直接访问
                b. 同名 : 外部类类名.this.外部类成员
            如果局部内部类所在方法 是静态方法 : 想要访问外部类成员 -> 创建外部类对象

        局部内部类只能在其所在的方法内使用,出了方法就用不了 !!

        局部内部类在其所在方法内使用时,还需要注意代码顺序 !! -> 必须在类定义之后使用 !!
```

## 4. 匿名对象

```java
匿名 : 没有名字
    
匿名对象 : 没有对象名的对象 
    
好处 : 省去了接收对象地址的过程
    
坏处 : 如果此对象需要重复使用时,就必须创建新的对象 !
    
总结 : 何时使用匿名对象 --> 当一个对象只使用一次的时候,那么可以使用匿名对象 //为了代码的简便
```

### 4.1 匿名内部类[重点]

```java
匿名内部类 : 是关于接口[父类/抽象父类]的另一种使用方式
    
    
格式 : 
	//匿名内部类的语句其实是一句多态 [Fu fu = new Zi()]
	父类型 父引用 = new 父类型(){
        //大括号内容是左边父类型的一个不知类名的实现类的类主体
      	//重写父类的方法  
    };

	//后续使用 :
	父引用.重写后的方法();

匿名内部类的编写技巧 : 从等号左边开始写
```

# 对象关联

- 对象关联 : 一个对象完全拥有另外一个对象, 因为我要频繁地使用这个对象.
- 如何关联 : 在当前类中把另外的对象作为我的属性即可
- 后续处理 :
- 1 处理全参构造器
- 2 提供get/set方法
- 3 改造toString
