# 并发编程概念

## ★进程和线程 

进程是资源分配的最小单位, 即一个程序的执行过程
线程是功能执行的最小单位：一个进程中可以多个线程，最少要有一个线程。

## ★并行和并发
并行：多项工作一起执行，之后再汇总
例子：泡方便面，电水壶烧水，一边撕调料倒入桶中。腿、脑
并发：同一时刻多个线程在访问同一个资源，多个线程对一个点
例子: 春运抢票 电商秒杀...

## ★同步和异步

- **同步**：调用某个任务时，会一直等待该任务完成，然后才继续执行后续的代码
- **异步**：调用某个任务时，不必等待任务完成就可以继续执行其他代码。

## ★wait/sleep
wait：**放开手去睡**，放开手里的锁
sleep：**握紧手去睡**，醒了手里还有锁
wait是Object的方法，sleep是thread的方法

| **对比项** | **所属类** | **是否释放锁** | **底层实现** |
| --- | --- | --- | --- |
| sleep() | Thread | 不释放锁 | C |
| wait() | Object | 释放锁 | C |

## ★如何创建线程

一般来说创建线程有五种方式 实际上有10种方式创建  

常用的三种 继承`Thread`类    实现`runnable`接口       实现`Callable`接口 

除此之外  实现线程池        使用`CompletableFuture`类等等



**但最终都是通过`new Thread().start()`创建**



1. **继承**`**Thread**`**类**：创建一个新类继承`Thread`类，并重写`run()`方法。然后创建该类的实例，调用`start()`方法启动线程。

```java
class MyThread extends Thread {
    public void run() {
        // 线程执行的代码
    }
}
```

1. **实现**`**Runnable**`**接口**：创建一个实现`Runnable`接口的类，并实现`run()`方法。然后创建`Thread`实例，将`Runnable`对象作为参数传递给`Thread`构造函数，调用`start()`方法启动线程。

```java
class MyRunnable implements Runnable {
    public void run() {
        // 线程执行的代码
    }
}
```

1. **使用**`**ExecutorService**`**和**`**Future**`：通过`ExecutorService`创建线程池，然后提交`Runnable`或`Callable`任务到线程池。`ExecutorService`管理线程的生命周期，并且可以控制线程的并发数。

```java
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.execute(new MyRunnable());
executor.shutdown();
```

2. **使用**`**ForkJoinPool**`：`ForkJoinPool`是一种特殊的线程池，用于执行`ForkJoinTask`任务。它适用于可以分解成更小任务的并行计算。

```java
ForkJoinPool forkJoinPool = new ForkJoinPool();
ForkJoinTask<Integer> task = new MyForkJoinTask();
forkJoinPool.execute(task);
```

这四种方式各有优势，适用于不同的场景。继承`Thread`类和实现`Runnable`接口是最基本的方式，适用于简单的并发任务。使用`ExecutorService`和`Future`提供了更高级的线程管理和任务控制功能，适用于复杂的并发应用。`ForkJoinPool`则专为并行计算设计，适用于可以分解成更小任务的大规模并行计算。

**Callable接口**

**Thread**类、**Runnable**接口使得多线程编程简单直接。但Thread类和Runnable接口**都不允许声明检查型异常**，

也不能定义**返回值**。

**public void run()**方法规范意味着你必须捕获并处理检查型异常。即使你小心捕获异常，也不能保证这个类

（Runnable对象）的所有使用者都读取异常信息。以上两个问题现在都得到了解决。**从java5开始，提供了**

**Callable接口，是Runable接口的增强版。**



用Call()方法作为线程的执行体，增强了之前的run()方法。因为call方法可以有返回值，也可以声明抛出异常。

ex:

```java
/**
 * 1. 创建Callable的实现类，并重写call()方法，该方法为线程执行体，并且该方法有返回值
 */
class MyCallableThread implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + "执行了！");
        return 200;
    }
}

public class CallableDemo {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 2. 创建Callable的实例，并用FutureTask类来包装Callable对象
        // 3. 创建FutureTask对象，需要一个Callable类型的参数
        FutureTask task = new FutureTask<Integer>(new MyCallableThread());
        // 4. 创建多线程，由于FutureTask的本质是Runnable的实现类，所以第一个参数可以直接使用task
        new Thread(task, "threadName").start();
        //new Thread(task, "threadName2").start();
		
        /*while (!task.isDone()) {
            System.out.println("wait...");
        }*/
        System.out.println(task.get());
        System.out.println(Thread.currentThread().getName() + " over!");
    }
}
```

FutureTask：未来的任务，用它就干一件事，**异步调用。通常用它解决耗时任务，挂起堵塞问题。**

在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，

当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。

一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。

FutureTask仅在call方法完成时才能get结果；如果计算尚未完成，则阻塞 get 方法。

一旦计算完成，就不能再重新开始或取消计算。get方法获取结果只有在计算完成时获取，否则会一直阻塞直到任

务转入完成状态，然后会返回结果或者抛出异常。 



注意点：

1.get()是阻塞式等待，拿不到结果就一直等。get()方法一定要放在start()方法【开启多线程】之后。

2.每个FutureTask对象对应一个线程，有几个FutureTask对象对象就能创建几个线程。

3.通过FutureTask对象isDone()方法可以知道该线程是否已经执行结束。



### ★ callable接口与runnable接口的区别？

相同点：**都是接口，都可以编写多线程程序，都采用Thread.start()启动线程**

不同点：

1. 具体方法不同：一个是run，一个是call
2. Runnable没有**返回值**；Callable可以返回执行结果，是个泛型
3. Callable接口的call()方法允许抛出**异常**；Runnable的run()方法异常只能在内部消化，不能往上继续抛
4. 它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。

## ★线程的生命周期

- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
- RUNNABLE: 运行状态，线程被调用了 `start()`   等待运行的状态。 
- BLOCKED：阻塞状态，需要等待锁释放。
- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

## ★死锁

多个程序同时阻塞 争夺同一资源 

**如何检测死锁**

使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

采用 VisualVM、JConsole 等工具进行排查

**如何避免死锁**

破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

Lock.tryLock()方法

## ★乐观锁和悲观锁

### 悲观锁

悲观锁认为共享资源每次访问的都会出问题, 所以每次在线程获取资源操作的时候上锁  当一个线程拿到资源 其他线程阻塞,用完在把资源转给其他线程



`synchronized`和`ReentrantLock`等独占锁都是悲观锁

```java
public void performSynchronisedTask() {
    synchronized (this) {
        // 需要同步的操作
    }
}

private Lock lock = new ReentrantLock();
lock.lock();
try {
   // 需要同步的操作
} finally {
    lock.unlock();
}
```

高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，**悲观锁还可能会存在死锁问题**，影响代码的正常运行.  多用于读多写少的情况下



### 乐观锁

悲观锁认为共享资源每次访问的都不会出问题, 无需加锁 线程可以不停访问 只有在提交和修改的时候去验证的资源是否被其他线程修改了(版本号机制,cas算法  来实现)



atomic类包下的原子变量类`AtomicInteger`、`LongAdder` 就是基于cas算法实现的乐观锁





高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。

####  版本号机制

#### CAS

先比较再交换
CAS操作有3个基本参数：内存地址A，旧值B，新值C。它的作用是将指定内存地址A的内容与所给的旧值B相比，如果相等，则将其内容替换为指令中提供的新值C；如果不等，则更新失败。类似于修改登陆密码的过程。当用户输入的原密码和数据库中存储的原密码相同，才可以将原密码更新为新密码，否则就不能更新。

**CAS是解决多线程并发安全问题的一种乐观锁算法。**因为它在对共享变量更新之前，会先比较当前值是否与更新前的值一致，如果一致则更新，如果不一致则循环执行（称为自旋锁），直到当前值与更新前的值一致为止，才执行更新。

```java
// 对象、对象的属性地址偏移量、预期值、修改值
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

Unsafe简单demo：

```java
public class UnsafeDemo {

    private int number = 0;

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        UnsafeDemo unsafeDemo = new UnsafeDemo();
        System.out.println(unsafeDemo.number);// 修改前
        unsafeDemo.compareAndSwap(0, 30);
        System.out.println(unsafeDemo.number);// 修改后
    }

    public void compareAndSwap(int oldValue, int newValue){
        try {
            // 通过反射获取Unsafe类中的theUnsafe对象
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true); // 设置为可见
            Unsafe unsafe = (Unsafe) theUnsafe.get(null); // 获取Unsafe对象
            // 获取number的偏移量
            long offset = unsafe.objectFieldOffset(UnsafeDemo.class.getDeclaredField("number"));
            // cas操作
            unsafe.compareAndSwapInt(this, offset, oldValue, newValue);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```

##### 基本代码演示

这里以AtomicInteger这个类来演示：

```java
public class CasDemo {

    public static void main(String[] args) {
        AtomicInteger i = new AtomicInteger(1);
        System.out.println("第一次更新：" + i.compareAndSet(1, 200));
        System.out.println("第一次更新后i的值：" + i.get());
        System.out.println("第二次更新：" + i.compareAndSet(1, 300));
        System.out.println("第二次更新后i的值：" + i.get());
        System.out.println("第三次更新：" + i.compareAndSet(200, 300));
        System.out.println("第三次更新后i的值：" + i.get());
    }
}
```

输出结果如下：

```
第一次更新：true
第一次更新后i的值：200
第二次更新：false
第二次更新后i的值：200
第三次更新：true
第三次更新后i的值：300
```

结果分析：

```
第一次更新：i的值（1）和预期值（1）相同，所以执行了更新操作，把i的值更新为200
第二次更新：i的值（200）和预期值（1）不同，所以不再执行更新操作
第三次更新：i的值（200）和预期值（1）相同，所以执行了更新操作，把i的值更新为300
```

##### 验证原子性缺点

**开销大**：在并发量比较高的情况下，如果反复尝试更新某个变量，却又一直更新不成功，会给CPU带来较大的压力

**ABA问题**：当变量从A修改为B再修改回A时，变量值等于期望值A，但是无法判断是否修改，CAS操作在ABA修改后依然成功。版本号

**不能保证代码块的原子性**：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。



# 线程间通信

```java
1.先定义资源类、属性和方法
2.在资源类中写方法的时候：
    2.1 判断(while判断类属性)
    2.2 干活
    2.3 唤醒
3.通过多线程操作资源类中的方法
```
