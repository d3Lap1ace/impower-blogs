import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as n}from"./app-B2i8EhLh.js";const l={},h=n(`<h1 id="java-oop" tabindex="-1"><a class="header-anchor" href="#java-oop"><span>Java_oop</span></a></h1><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    @markdownname javaSE_oop</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    @Auther d3Lap1ace</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    @Time 2024/03/26:下午6:22</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    @Version 1.0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                        From the Laplace of Demon </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">**/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>面向对象 : 更侧重于对象使用的一种编程方式     <strong>本质上是以类的方式组织代码 以对象的调用方法实现功能</strong></li><li>面向过程 : 更侧重于编程过程书写的一种编程方式     (自个动手造轮子哦~)</li></ol><h1 id="面向对象编程三大特征" tabindex="-1"><a class="header-anchor" href="#面向对象编程三大特征"><span>面向对象编程三大特征</span></a></h1><p><strong>封装性:  数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。防止该类的代码和数据被外部类定义的代码随机访问 防止注入</strong></p><p>**继承性:  **继承实现了 <strong>IS-A</strong> 关系 <strong>子类继承父类完全还更强大。</strong></p><p><strong>多态性:</strong>  <strong>当作用在不同的对象时，会产生不同的结果</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 事物的描述</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 属性 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 描述事物的特征</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 描述事物的行为动作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">类是对象的模板，对象是类的实体</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="封装性" tabindex="-1"><a class="header-anchor" href="#封装性"><span>封装性</span></a></h1><p><strong>防止该类的代码和数据被外部类定义的代码随机访问  通过private关键字修饰变量和方法, 只暴露对外的setter和getter方法 和 构造器 来实现对对象的属性的设定和获取.</strong></p><h2 id="_1-访问权限修饰符" tabindex="-1"><a class="header-anchor" href="#_1-访问权限修饰符"><span>1. 访问权限修饰符</span></a></h2><blockquote></blockquote><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">访问权限修饰符 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 公共的   </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 整个模块下都可以访问</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 受保护的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  最大权限是 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不同包有继承关系  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">不写 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 默认的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 只能在同一个包下访问</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 私有的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 只能在同一个类中访问</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Java 不可以跨越模块访问成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th></th><th>在本类中</th><th>在同一个包下</th><th>不同包下有继承关系</th><th>不同包无关类</th></tr></thead><tbody><tr><td><strong>public</strong></td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>protected</strong></td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td><strong>不写</strong></td><td>√</td><td>√</td><td></td><td></td></tr><tr><td><strong>private</strong></td><td>√</td><td></td><td></td><td></td></tr></tbody></table><h2 id="_2-getter-and-setter方法" tabindex="-1"><a class="header-anchor" href="#_2-getter-and-setter方法"><span>2. getter and setter方法</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">当属性被私有修饰之后</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">还需要给属性提供公共的访问</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // 留接口 后门</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">getXxx 方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 获取属性值的方法            </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        返回值类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Xxx属性的类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        形参列表 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 无形参的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">setXxx方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 设置该属性值的方法           </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        返回值类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        形参列表 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (Xxx属性的类型 变量名)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-变量访问的就近原则问题" tabindex="-1"><a class="header-anchor" href="#_3-变量访问的就近原则问题"><span>3. 变量访问的就近原则问题</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量访问时有远近关系 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	局部位置 比 成员位置 要近 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量访问的就近原则问题 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当访问变量时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 变量会优先访问离自己最近的那个变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">      </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">想要打破变量的就近访问问题 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	打破局部位置变量的访问</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">强制访问本类成员位置上的变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量名</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-this-关键字" tabindex="-1"><a class="header-anchor" href="#_3-1-this-关键字"><span>3.1  this 关键字</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 关键字 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   // 谁调用this就是谁  也是 当前对象的引用</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 强制访问本类成员位置上的变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 打破变量就近访问原则的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法名(实参) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 强制访问本类成员位置上的方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不会这样写 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 因为不存在局部方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 只要是在访问方法就一定访问的是 成员方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 所以可以省略 </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-局部变量和成员变量的区别" tabindex="-1"><a class="header-anchor" href="#_3-2-局部变量和成员变量的区别"><span>3.2 局部变量和成员变量的区别</span></a></h3><table><thead><tr><th>区别</th><th>局部变量</th><th>成员变量</th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>其所在的方法内</td><td>整个类中有效 [全局]</td></tr><tr><td><strong>默认值</strong></td><td>没有</td><td>有默认值</td></tr><tr><td><strong>位置不同</strong></td><td>方法内,方法的形参上</td><td>类中方法外</td></tr><tr><td><strong>生命周期</strong></td><td>随着方法的调用产生,随着方法的执行完毕死亡</td><td>随着对象的创建产生,随着对象的死亡而死亡</td></tr><tr><td><strong>内存中的位置不同</strong></td><td>栈内存中</td><td>堆内存中</td></tr><tr><td><strong>在IDEA中的颜色不同</strong></td><td>黑色</td><td>紫色</td></tr></tbody></table><blockquote><p>成员变量,成员方法 都 属于对象 !</p><p>记忆技巧 :</p><ol><li>因为在类中位置不同,所以导致作用域不同和在内存中的位置不同</li><li>因为在内存中位置不同,所以导致默认值不同和生命周期不同</li></ol></blockquote><blockquote><p>如果变量,方法没有被使用时 : 颜色是灰的 !</p></blockquote><h2 id="_4-构造方法-构造器" tabindex="-1"><a class="header-anchor" href="#_4-构造方法-构造器"><span>4. 构造方法 [构造器]</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">构造方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 虽然是方法</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">但是是特殊的方法 [和其他方法有多不一样的地方</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">但是本质上是方法]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 封装了特定功能的代码块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">构造 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 构建 创造 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 用来构建和创造 </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;对象&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 的方法   </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">构造方法的格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//无参构造</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	访问权限修饰符 类名(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //方法体;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//有参构造/带参构造</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	访问权限修饰符 类名(形参列表){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //方法体;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">注意事项 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">	1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 构造方法是通过关键字 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 来调用的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 构造方法的名字必须和类名 一模一样 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 大小写都一样 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//构造方法不遵循小驼峰式命名    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 构造方法是没有 返回值类型 这个板块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 连 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 都不可以写 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //因为调用完构造方法的结果一定是生成了一个此类对象  !    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 如果在一个类中没有定义构造方法</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">JVM会赠送一个 默认的无参构造  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在一个类中是可以有多个构造方法的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 写无参构造</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 写有参构造 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //构造方法是可以重载的 !!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    6.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 只要你在类中定义了构造</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么JVM默认赠送的构造方法就不送的了 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    7.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 就算有构造方法 也不能省略 set 方法的编写 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 因为 set方法可以修改对象的属性 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 而构造一旦new出来</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">一定生成了新的对象的</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-1-构造方法和普通方法的区别" tabindex="-1"><a class="header-anchor" href="#_4-1-构造方法和普通方法的区别"><span>4.1. 构造方法和普通方法的区别</span></a></h3><p>编写代码的角度：声明格式、作用都不同。但是语法格式相似，调用方式相似通过：方法名(实参列表)。</p><p>字节码文件的角度：构造器会以<code>&lt;init&gt;()方法</code>的形态呈现，用以初始化对象。</p><h3 id="_4-2-类的构造器能不能调用这个类中的其他构造器" tabindex="-1"><a class="header-anchor" href="#_4-2-类的构造器能不能调用这个类中的其他构造器"><span>4.2 类的构造器能不能调用这个类中的其他构造器?</span></a></h3><p>能  this()和super()都是构造器，this()调用本类构造器，super()调用父类构造器</p><h2 id="_5-static-final-关键字" tabindex="-1"><a class="header-anchor" href="#_5-static-final-关键字"><span>5. static final 关键字</span></a></h2><h3 id="_5-1-final" tabindex="-1"><a class="header-anchor" href="#_5-1-final"><span>5.1 final</span></a></h3><ol><li>数据</li></ol><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// x = 2;  // cannot assign value to final variable &#39;x&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>方法</li></ol><p>声明方法不能被子类重写。<br> private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><ol start="3"><li>类</li></ol><p>声明类不允许被继承。</p><h3 id="_5-2-static" tabindex="-1"><a class="header-anchor" href="#_5-2-static"><span>5.2 static</span></a></h3><p>static 关键字的特点 :</p><ol><li>被static修饰的成员被所有对象所共享 -&gt; 一变则都变</li><li>被static修饰的成员不属于单个对象,而是属于类 -&gt; 属于类</li><li>被static修饰的成员可以直接使用类名调用 -&gt; 类名调</li><li>被static修饰的成员[类属性]随着类的加载而加载优先于对象 -&gt; 随着类<br><strong>// 被static关键字修饰的成员 变成了 类  而不是 对象</strong></li></ol><h3 id="_5-3-静态成员的访问问题" tabindex="-1"><a class="header-anchor" href="#_5-3-静态成员的访问问题"><span>5.3 静态成员的访问问题</span></a></h3><table><thead><tr><th></th><th>非静态成员变量静态成员的访问问题</th><th>非静态成员方法</th><th>静态成员变量</th><th>静态成员方法</th></tr></thead><tbody><tr><td><strong>非静态成员方法</strong></td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>静态成员方法</strong></td><td>X</td><td>X</td><td>√</td><td>√</td></tr></tbody></table><h3 id="_5-2-静态的使用场景" tabindex="-1"><a class="header-anchor" href="#_5-2-静态的使用场景"><span>5.2 静态的使用场景</span></a></h3><p>静态的使用场景在定义工具类的时候,把工具类中所有的成员变量和成员方法全部用static修饰 -&gt; 目的是为了更方便使用工具类的程序员调用工具类的方法 -&gt; 可以不创建工具类的对象,直接使用工具类的类名调用类中的方法 !</p><p>工具类的定义步骤 :</p><ol><li>定义类 -&gt; 类名 : XxxxUtils</li><li>把类中无参构造用 private 修饰 并不提供任何其他构造方法 -&gt; 目的: 不让使用工具类的程序员创建工具类的对象, 因为工具类中所有的成员变量和成员方法都用static修饰,可以使用类名调用</li><li>把工具类中所有的 成员变量和成员方法都用 static 修饰</li></ol><h3 id="_5-3-初始化顺序" tabindex="-1"><a class="header-anchor" href="#_5-3-初始化顺序"><span><strong>5.3 初始化顺序</strong></span></a></h3><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1 id="继承性" tabindex="-1"><a class="header-anchor" href="#继承性"><span>继承性</span></a></h1><p>在一个现有类的基础上通过<strong>extends</strong>关键字构建一个新类，子类可以拥有父类的<strong>成员变量以及成员方法</strong>（但是不一定能访问或调用，比如父类中private私有的成员变量以及方法不能访问和调用）。**继承的作用就是能提高代码的复用性。**它可以访问和使用父类中的非私有成员变量，以及重写父类中的非私有成员方法。</p><p>//  java是单一继承   c++是多个继承</p><h2 id="_1-继承关系下成员变量访问问题" tabindex="-1"><a class="header-anchor" href="#_1-继承关系下成员变量访问问题"><span>1. 继承关系下成员变量访问问题</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">继承关系下 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 成员变量的访问特点 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在子类中访问父类成员</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 私有的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问不了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不同名的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 直接访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 同名的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 就近原则</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">                this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">num</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类成员位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">                super</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">num</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类父类成员位置</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在父类中访问子类成员</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 直接访问 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问不了 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父类不知道自己有哪些子类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 创建子类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 通过子类对象调用子类自己的成员变量</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">创建子类对象访问父类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 私有的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问不了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不同名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类对象直接访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 同名的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类对象只能访问自己类中的同名变量</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">访问不了父类的同名变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 就近原则</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">创建父类对象访问子类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不可以   </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//不如直接创建子类对象  :D</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            // 总结 : 成员方法的调用不遵循就近原则[没有就近原则],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">           // 具体调用的的哪个方法需要看调用方法真实对象的类型 (看new谁)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-继承关系下构造方法访问问题" tabindex="-1"><a class="header-anchor" href="#_1-1-继承关系下构造方法访问问题"><span>1.1 继承关系下构造方法访问问题</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类对象要加载 优先加载父类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用其他构造方法的代码(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(实参)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(实参))必须是构造方法的第一句</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 如果在构造方法内 调用了其他构造方法</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么默认赠送的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() 就不送了 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类构造方法中 必须有一个构造方法去 加载父类  </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-this-和-super-关键字" tabindex="-1"><a class="header-anchor" href="#_2-this-和-super-关键字"><span>2. this 和 super 关键字</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">实操层面 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">	super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用本类父类的无参构造方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(实参) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用本类父类的有参构造方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用本类的无参构造方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(实参) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用本类的有参构造方法</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类的成员变量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法名() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类的无参方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法名(实参) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类的有参方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">变量名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类父类的成员变量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法名() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类父类的无参成员方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法名(实参) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 访问本类父类的有参成员方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 打破局部位置的访问就近原则 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    super</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 打破本类成员位置的访问就近原则 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--------------------------------------------------------</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">概念层面 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">	this</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当前对象的引用 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        哪个对象启动含有this关键字的方法</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么方法内的this关键字就指向哪个对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 对象照镜子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">   super</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父类的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 关键字不指向父类对象 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 因为当子类对象创建时并没有生成一个具体的父类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-★方法的重写" tabindex="-1"><a class="header-anchor" href="#_3-★方法的重写"><span>3. ★方法的重写</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法的重载 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Overload </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用的多</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">定义少</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须在同一个类中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须方法名相同</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 形参列表必须不同 [数量</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">类型</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">类型顺序]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 与 返回值类型 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 方法体 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 形参变量名 无关</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">方法的重写 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Override  </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 调用的多</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">定义的也多</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须有继承关系 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 实现关系 [两个方法不再同一个类中]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类重写父类的方法 要求 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类方法的声明</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">父类方法的声明 一模一样 [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">99</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">情况]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 方法体不一样 [子类覆盖父类的方法]    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类重写方法的访问权限修饰符 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父类方法的访问权限修饰符</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 方法的返回值类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">		a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须一样</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 基本数据类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须一样</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 引用数据类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类重写方法的返回值类型 必须是 父类方法返回值类型的 同类型或者子类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //假设父类是大 子类是小 --&gt; 子类重写方法的返回值类型 &lt;= 父类方法返回值类型的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">     6.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类重写方法抛出的受检异常不能大于等于父类方法抛出的异常</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">注意事项 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">	1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 私有方法不存在重写概念</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 修饰的方法 不存在重写概念  </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当方法被加上static关键字</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么方法就属于类了</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">而方法的重写时子类方法对父类方法的一种延续[覆盖]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">两个方法是关系的 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 加上static让2个方法就没有了关系</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">各自属于各自的类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="多态性" tabindex="-1"><a class="header-anchor" href="#多态性"><span>多态性</span></a></h1><p><strong>当作用在不同的对象时，会产生不同的结果</strong>     对象  进入 盲盒            XD</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 父类和子类中的同名属性不具备多态性, 因为它们是共存关系.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 静态方法也不具备多态性, 因为它们不是覆盖关系, 是共存关系</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 只有非静态方法(对象方法)具备多态性.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 类中的真正成员(具有描述性) : 属性, 方法, 内部类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 伪成员 : 构造器, 语句块</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 多态本质: 把子类对象&quot;当作&quot;是父类对象.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> */</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-多态的前提条件" tabindex="-1"><a class="header-anchor" href="#_1-多态的前提条件"><span>1. 多态的前提条件</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">	1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须有继承</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">实现关系  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须有 父引用接收子类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子引用强制接收父引用 的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        父引用接收子类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Fu</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fu </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Zi</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">			//例如 : Human human = new Man();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">			//例如 : Animal animal = new Dog(); 任意一只狗都是动物</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	    子引用接收父引用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  Zi</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> zi </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (Zi)fu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // 当fu真的是在接收一个子类对象时</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">	3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类重写父类中的方法 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//不是多态的必要条件,但是有这件事情可以让父引用的方法调用出现动态绑定特性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">			[错误] </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Zi</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> zi </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Fu</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // Dog dog = new Animal();  任意一只动物都是狗 ?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-多态的向上转型和向下转型" tabindex="-1"><a class="header-anchor" href="#_1-1-多态的向上转型和向下转型"><span>1.1 多态的向上转型和向下转型</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">向上转型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 由子类对象变成父类引用 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    Fu</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fu </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Zi</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //Animal animal = new Dog();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">向下转型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 由父引用变成子引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    Zi</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> zi </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (Zi)fu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // Dog dog = (Dog)animal;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">多态[继承</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">实现]的弊端 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        父引用不能访问子类的特有成员 [成员变量</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">成员方法]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">多态[继承</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">实现]的弊端的解决方案 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 向下转型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">多态的弊端告诉我们 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 创建对象一定创建子类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类对象的功能最多 [父引用只能自己的不能访问子类特有的变量和方法]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-向下转型的弊端" tabindex="-1"><a class="header-anchor" href="#_1-2-向下转型的弊端"><span>1.2 向下转型的弊端</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">向下转型的弊端 </span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">ClassCastException</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> [类型转换异常] </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 向下转型出现了问题</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">向下转型由前提 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 对象的真实类型必须和你要转型的类型一致 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //是狗才能转换成狗, 是猫才能转换成猫 不能瞎转 [狗转猫,猫转狗]    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">如何解决向下转型的弊端 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在向下转型之前</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">做对象的类型判断 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //是猫转猫,是狗转狗</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(父引用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子类名){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //能进来说明 : 前面的父引用的真实类型是 后方子类型的 !</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-多态的真实使用场景" tabindex="-1"><a class="header-anchor" href="#_2-多态的真实使用场景"><span>2. 多态的真实使用场景</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// n 代表 此父类型由多少种子类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 1 代表 父类型自己的对象 [有时候可能没有这个1 : 当父类型是接口 / 抽象类]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 把父类型作为方法的形参</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么启动方法时能传入的实参类型是 n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 种 </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 把父类型作为方法的返回值类型</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么方法返回值的类型可以是 n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 种 </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 把父类型作为容器[数组</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">集合]元素的数据类型 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 那么此容器内能存储的对象类型是 n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 种    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在异常处理时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 抛出[throws]父类型异常</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">子类型异常一并抛出了</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在异常处理时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 捕获[</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]父类型异常,子类型异常一并被捕获了!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-多态的本质" tabindex="-1"><a class="header-anchor" href="#_3-多态的本质"><span>3. 多态的本质</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">多态的本质 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> Java种的多态描述的是Java引用数据类型子父类</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[实现类</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">父接口]之间的类型转换问题</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!!!!!!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">基本数据类型中有 自动提升 和 强制类型转换 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	基本数据类型能有此特性的前提是 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 基本数据类型之间有大小关系 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        [</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">short</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> float</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    自动提升 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 大类型的变量接收小类型的值</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //double num = 1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	强制转换 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 小类型的变量强制接收大类型的值</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // int i = (int)num;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		强转有弊端 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 精度损失 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 能不强转就不强转 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">引用数据类型中有 向上转型 和 向下转型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //前提 : 有继承/实现关系 -&gt; 因为有了继承和实现才有了类和类,类和接口之间的大小关系</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	子类型</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">实现类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父类型</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">父接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    向上转型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父引用接收子类对象 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// Fu fu = new Zi();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	向下转型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 子引用接收父引用 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// Zi zi = (Zi)fu;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        向下转型弊端 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fu[父引用]的真实类型必须是对应的子类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 多态中的向下转型使用非常频繁 </span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 因为父引用不能访问子类的特有行为</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">想去访问子类特有行为必须把父引用变成子类型对象</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="抽象类和接口" tabindex="-1"><a class="header-anchor" href="#抽象类和接口"><span>抽象类和接口</span></a></h1><h2 id="_1-抽象类" tabindex="-1"><a class="header-anchor" href="#_1-抽象类"><span>1. 抽象类</span></a></h2><p><strong>只要被 abstract 关键字修饰的类就是抽象类!   抽象类的存在就是为了封装抽象方法的!</strong></p><p>**//不能创建对象    **</p><p><strong>//在子类中重写抽象父类中所有的抽象方法</strong></p><blockquote><p>为什么要有抽象类 : 抽象类作为父类,对子类行为的约束增强 ! [子类继承抽象父类必须重写父类中所有的抽象方法]</p></blockquote><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">抽象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> abstract</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> 类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //抽象类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //无方法体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">抽象类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 抽象类中的成员</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有抽象方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有成员变量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有自定义常量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有构造方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有非静态方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    6.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 可以有静态方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">abstract</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 关键字不可以和哪些关键字一起用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">	1.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    2.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 抽象[</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">abstract</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]方法没有方法体</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">加上static后可以使用类名去启动 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 矛盾的</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    3.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  抽象[</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">abstract</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]方法必须让子类重写</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">而私有修饰子类看不见 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 矛盾的</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-接口" tabindex="-1"><a class="header-anchor" href="#_2-接口"><span>2.接口</span></a></h2><blockquote><p>接口 : 比抽象类更抽象的&quot;类&quot;叫接口</p><ul><li>属性全是全局常量 public static final</li><li>接口用于表达某种能力.或标准和规范.</li><li>面向接口编程 : 把子类对象多态为接口类型的对象来使用.</li><li>抽象方法</li><li>默认方法</li><li>静态方法</li><li>私有方法</li></ul></blockquote><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">接口 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 是Java引用数据类型中的一种 [类(class)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">数组(Array)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">接口(interface)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">枚举(enum)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">注解(</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">interface),记录</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(record)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">接口的定义格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> 接口名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-★接口与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#_3-★接口与抽象类的区别"><span>3.★接口与抽象类的区别</span></a></h2><p><strong>定义不同</strong>   抽象类用<code>abstract</code>关键字声明只能被继承    接口是使用<code>interface</code>关键字声明只能被实现</p><p><strong>成员方法不同</strong> 抽象类包含 抽象方法和非抽象方法  接口再jdk8之前只有抽象方法  jdk8之后新加了 默认方法  静态方法 和私有方法</p><p><strong>构造函数和成员的不同</strong>   抽象类可以有构造函数 可以有成员变量  接口不能有构造函数  只能有静态修饰的final变量</p><h2 id="_3-final-关键字" tabindex="-1"><a class="header-anchor" href="#_3-final-关键字"><span>3. final 关键字</span></a></h2><p>宏定义!!!!!!!!</p><p>// 不能被继承 重写 abstract修饰</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 关键字 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 最终的 a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 最终的类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 被 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 修饰的类 没有子类</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不能被继承</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 成员变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 最终的成员变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 被 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 修饰的成员变量 不能改变 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 变成了常量 [自定义常量]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    自定义常量的标准编写格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">		public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 数据类型 常量名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 初始化值</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //虽然它有默认值但是作为了常量必须由程序员赋予初始化值;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		自定义常量的标准命名方式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 全部大写</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">多个单词之间使用 下划线 分隔</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 成员方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 最终的成员方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 被 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 修饰的方法不能被重写 </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 局部变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 最终的局部变量 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 被 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 修饰的局部变量 不能改变 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 变成了 局部位置的常量   </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">被final修饰的对象 地址不可改变 地址上的内容可以改变</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="代码块" tabindex="-1"><a class="header-anchor" href="#代码块"><span>代码块</span></a></h1><blockquote><ol><li>局部代码块 : 在方法内的大括号</li><li>构造代码块 : 在成员位置的大括号</li><li>静态代码块 : 在成员位置被static修饰的大括号</li></ol></blockquote><h3 id="局部代码块" tabindex="-1"><a class="header-anchor" href="#局部代码块"><span>局部代码块</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">局部代码块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在方法内的大括号 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    作用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 控制局部变量的生命周期 [变量的作用域 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在其定义的大括号内有效]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    方法(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //局部代码块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            局部变量</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //上面的局部变量此时已经死亡</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">局部代码块现在使用非常非常非常少</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">因为内存的硬件水平已经很高了 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构造代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块"><span>构造代码块</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">构造代码块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 定义在成员位置的代码块 [全局代码块]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> 类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //成员位置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //构造代码块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            书写代码</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    构造代码块的执行时机 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        每当有对象创建时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">构造代码块就需要执行一次</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">优先于构造方法执行</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //千万不要误解构造代码块的执行时机 : 随着对象的创建而执行 [有几个对象创建就执行几次构造代码块,优先于对象创建执行 !]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    作用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 为对象创建做准备 [我们可以把对象创建之前需要做的准备工作写在构造代码块中]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    举例 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 构造代码块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 宫女</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">太监  对象</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 皇上</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块"><span>静态代码块</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">静态代码块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 定义在成员位置且被static修饰的代码块 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> 类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //成员位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        static</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //静态代码块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            书写代码</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    静态代码块的执行时机 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 随着类的加载而执行的</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">只执行一次 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 优先于构造代码块</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">优先于构造方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    静态代码块的作用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 为类的加载做准备的代码可以写在 静态代码块中</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    举例 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 静态代码块 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 驱动[类的驱动]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    小技巧 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当类中有静态代码块的时候</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">自定义常量定义时可以先定义后赋值</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 后赋值 必须要在静态代码块里面赋值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h1><blockquote><p>内部类 : 定义在类中的类 !</p><ol><li>成员内部类 : 定义在一个类成员位置的类</li><li>静态成员内部类 : 定义在一个类成员位置且被static修饰的类</li><li>局部内部类 : 定义在方法内的类 [了解]</li><li>匿名内部类 : 接口/抽象父类的另一种使用形式 [重点]</li></ol></blockquote><h2 id="_1-成员内部类" tabindex="-1"><a class="header-anchor" href="#_1-成员内部类"><span>1. 成员内部类</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * 内部类 :</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *      成员内部类 : 声明在类中方法外</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *              没有static修饰的 : 普通内部类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *              有static修饰的 : 嵌套类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *      局部内部类 : 声明在方法中</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *              普通局部内部类 :</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> *              匿名内部类(最重要) : 主要用于配合接口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> */</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">成员内部类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 定义在一个类成员位置的类 叫成员内部类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //外部类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //成员位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //成员内部类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    成员内部类的访问问题 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在内部类中访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">               a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不同名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 直接访问 [隐藏了 外部类类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">               b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 同名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">成员名称 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 外部类类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">成员名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">               </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在外部类中访问内部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 创建内部类对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中创建外部类对象访问内部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 弄不了</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 外部类对象只能调用外部类自己的成员变量和成员方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中创建内部类对象访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 弄不了</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 内部类对象只能调用内部类自己的成员变量和成员方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            在第三方类中创建内部类对象的公式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> inner </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">            --</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 有了内部类对象</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">自然可以在第三方类中访问内部类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">     使用场景 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当一个类只为另一个类服务时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">可以把第一个类定义在第二个类的内部 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> [A </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 发动机  B</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 汽车]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-静态成员内部类" tabindex="-1"><a class="header-anchor" href="#_2-静态成员内部类"><span>2. 静态成员内部类</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">静态成员内部类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 定义在一个类成员位置且被static修饰的类 叫静态成员内部类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //外部类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //成员位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //静态成员内部类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //只有当类是成员内部类时 这个类才能被 static 修饰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">静态成员内部类比成员内部类用的多 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在内部类中访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不能直接访问的 [加载时机问题]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            解决方案 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在内部类中创建外部类对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在外部类中访问内部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  不能用Inner类名直接访问Inner的成员 [因为Inner的成员没有被static修饰 所以还是属于Inner对象的]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            解决方案 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在外部类中创建内部类对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中创建外部类对象访问内部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 弄不了</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 外部类对象只能调用外部类自己的成员变量和成员方法</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">        4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在第三方类中创建内部类对象访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 弄不了</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 内部类对象只能调用内部类自己的成员变量和成员方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">               创建静态成员内部类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> inner </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">               创建成员内部类对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> inner </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-局部内部类" tabindex="-1"><a class="header-anchor" href="#_3-局部内部类"><span>3. 局部内部类</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">局部内部类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 定义在方法内的类 叫局部内部类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Outer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //外部类</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        外部类的方法</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">形参</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //局部位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Inner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//局部内部类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">局部内部类何时使用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当一个类只为一个方法服务时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">可以把这个类定义在这个方法内 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//此情况非常非常非常少见</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">		1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 在内部类中访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            局部内部类所在方法 不可以是静态方法</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">                a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 不同名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 直接访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">                b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 同名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 外部类类名</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">外部类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            如果局部内部类所在方法 是静态方法 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 想要访问外部类成员 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 创建外部类对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        局部内部类只能在其所在的方法内使用</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">出了方法就用不了 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        局部内部类在其所在方法内使用时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">还需要注意代码顺序 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 必须在类定义之后使用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-匿名对象" tabindex="-1"><a class="header-anchor" href="#_4-匿名对象"><span>4. 匿名对象</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">匿名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 没有名字</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">匿名对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 没有对象名的对象 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">好处 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 省去了接收对象地址的过程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">坏处 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 如果此对象需要重复使用时</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">就必须创建新的对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">总结 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 何时使用匿名对象 </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 当一个对象只使用一次的时候</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">那么可以使用匿名对象 </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//为了代码的简便</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-1-匿名内部类-重点" tabindex="-1"><a class="header-anchor" href="#_4-1-匿名内部类-重点"><span>4.1 匿名内部类[重点]</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">匿名内部类 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 是关于接口[父类</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">抽象父类]的另一种使用方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">格式 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//匿名内部类的语句其实是一句多态 [Fu fu = new Zi()]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	父类型 父引用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 父类型(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //大括号内容是左边父类型的一个不知类名的实现类的类主体</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      	//重写父类的方法  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//后续使用 :</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	父引用</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">重写后的方法()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">匿名内部类的编写技巧 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 从等号左边开始写</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="对象关联" tabindex="-1"><a class="header-anchor" href="#对象关联"><span>对象关联</span></a></h1><ul><li>对象关联 : 一个对象完全拥有另外一个对象, 因为我要频繁地使用这个对象.</li><li>如何关联 : 在当前类中把另外的对象作为我的属性即可</li><li>后续处理 :</li><li>1 处理全参构造器</li><li>2 提供get/set方法</li><li>3 改造toString</li></ul>`,119),t=[h];function k(e,p){return a(),s("div",null,t)}const g=i(l,[["render",k],["__file","02.Java_oop.html.vue"]]),y=JSON.parse('{"path":"/backend/02.Java_oop.html","title":"Java_oop","lang":"zh-CN","frontmatter":{"description":"Java_oop 面向对象 : 更侧重于对象使用的一种编程方式 本质上是以类的方式组织代码 以对象的调用方法实现功能 面向过程 : 更侧重于编程过程书写的一种编程方式 (自个动手造轮子哦~) 面向对象编程三大特征 封装性: 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。防止该类的代码和数据被外部类定义的...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/impower-blogs/backend/02.Java_oop.html"}],["meta",{"property":"og:site_name","content":"impower"}],["meta",{"property":"og:title","content":"Java_oop"}],["meta",{"property":"og:description","content":"Java_oop 面向对象 : 更侧重于对象使用的一种编程方式 本质上是以类的方式组织代码 以对象的调用方法实现功能 面向过程 : 更侧重于编程过程书写的一种编程方式 (自个动手造轮子哦~) 面向对象编程三大特征 封装性: 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。防止该类的代码和数据被外部类定义的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-21T07:09:46.000Z"}],["meta",{"property":"article:author","content":"luke.lewis"}],["meta",{"property":"article:modified_time","content":"2024-07-21T07:09:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java_oop\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-21T07:09:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luke.lewis\\",\\"url\\":\\"https://github.com/d3Lap1ace\\",\\"email\\":\\"aegonk@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 访问权限修饰符","slug":"_1-访问权限修饰符","link":"#_1-访问权限修饰符","children":[]},{"level":2,"title":"2. getter and setter方法","slug":"_2-getter-and-setter方法","link":"#_2-getter-and-setter方法","children":[]},{"level":2,"title":"3. 变量访问的就近原则问题","slug":"_3-变量访问的就近原则问题","link":"#_3-变量访问的就近原则问题","children":[{"level":3,"title":"3.1  this 关键字","slug":"_3-1-this-关键字","link":"#_3-1-this-关键字","children":[]},{"level":3,"title":"3.2 局部变量和成员变量的区别","slug":"_3-2-局部变量和成员变量的区别","link":"#_3-2-局部变量和成员变量的区别","children":[]}]},{"level":2,"title":"4. 构造方法 [构造器]","slug":"_4-构造方法-构造器","link":"#_4-构造方法-构造器","children":[{"level":3,"title":"4.1. 构造方法和普通方法的区别","slug":"_4-1-构造方法和普通方法的区别","link":"#_4-1-构造方法和普通方法的区别","children":[]},{"level":3,"title":"4.2 类的构造器能不能调用这个类中的其他构造器?","slug":"_4-2-类的构造器能不能调用这个类中的其他构造器","link":"#_4-2-类的构造器能不能调用这个类中的其他构造器","children":[]}]},{"level":2,"title":"5. static  final  关键字","slug":"_5-static-final-关键字","link":"#_5-static-final-关键字","children":[{"level":3,"title":"5.1 final","slug":"_5-1-final","link":"#_5-1-final","children":[]},{"level":3,"title":"5.2 static","slug":"_5-2-static","link":"#_5-2-static","children":[]},{"level":3,"title":"5.3 静态成员的访问问题","slug":"_5-3-静态成员的访问问题","link":"#_5-3-静态成员的访问问题","children":[]},{"level":3,"title":"5.2 静态的使用场景","slug":"_5-2-静态的使用场景","link":"#_5-2-静态的使用场景","children":[]},{"level":3,"title":"5.3 初始化顺序","slug":"_5-3-初始化顺序","link":"#_5-3-初始化顺序","children":[]}]},{"level":2,"title":"1. 继承关系下成员变量访问问题","slug":"_1-继承关系下成员变量访问问题","link":"#_1-继承关系下成员变量访问问题","children":[{"level":3,"title":"1.1 继承关系下构造方法访问问题","slug":"_1-1-继承关系下构造方法访问问题","link":"#_1-1-继承关系下构造方法访问问题","children":[]}]},{"level":2,"title":"2. this 和 super 关键字","slug":"_2-this-和-super-关键字","link":"#_2-this-和-super-关键字","children":[]},{"level":2,"title":"3. ★方法的重写","slug":"_3-★方法的重写","link":"#_3-★方法的重写","children":[]},{"level":2,"title":"1. 多态的前提条件","slug":"_1-多态的前提条件","link":"#_1-多态的前提条件","children":[{"level":3,"title":"1.1 多态的向上转型和向下转型","slug":"_1-1-多态的向上转型和向下转型","link":"#_1-1-多态的向上转型和向下转型","children":[]},{"level":3,"title":"1.2 向下转型的弊端","slug":"_1-2-向下转型的弊端","link":"#_1-2-向下转型的弊端","children":[]}]},{"level":2,"title":"2. 多态的真实使用场景","slug":"_2-多态的真实使用场景","link":"#_2-多态的真实使用场景","children":[]},{"level":2,"title":"3. 多态的本质","slug":"_3-多态的本质","link":"#_3-多态的本质","children":[]},{"level":2,"title":"1. 抽象类","slug":"_1-抽象类","link":"#_1-抽象类","children":[]},{"level":2,"title":"2.接口","slug":"_2-接口","link":"#_2-接口","children":[]},{"level":2,"title":"3.★接口与抽象类的区别","slug":"_3-★接口与抽象类的区别","link":"#_3-★接口与抽象类的区别","children":[]},{"level":2,"title":"3. final 关键字","slug":"_3-final-关键字","link":"#_3-final-关键字","children":[{"level":3,"title":"局部代码块","slug":"局部代码块","link":"#局部代码块","children":[]},{"level":3,"title":"构造代码块","slug":"构造代码块","link":"#构造代码块","children":[]},{"level":3,"title":"静态代码块","slug":"静态代码块","link":"#静态代码块","children":[]}]},{"level":2,"title":"1. 成员内部类","slug":"_1-成员内部类","link":"#_1-成员内部类","children":[]},{"level":2,"title":"2. 静态成员内部类","slug":"_2-静态成员内部类","link":"#_2-静态成员内部类","children":[]},{"level":2,"title":"3. 局部内部类","slug":"_3-局部内部类","link":"#_3-局部内部类","children":[]},{"level":2,"title":"4. 匿名对象","slug":"_4-匿名对象","link":"#_4-匿名对象","children":[{"level":3,"title":"4.1 匿名内部类[重点]","slug":"_4-1-匿名内部类-重点","link":"#_4-1-匿名内部类-重点","children":[]}]}],"git":{"createdTime":1720960541000,"updatedTime":1721545786000,"contributors":[{"name":"d3lap1ace L.Lewis","email":"ap1cem@163.com","commits":2}]},"readingTime":{"minutes":24.67,"words":7401},"filePathRelative":"backend/02.Java_oop.md","localizedDate":"2024年7月14日","autoDesc":true}');export{g as comp,y as data};
