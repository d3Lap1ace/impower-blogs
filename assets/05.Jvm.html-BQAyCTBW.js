import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as n}from"./app-BVSe6w44.js";const l="/impower-blogs/assets/image-1721009547033-12-CJaoDVld.png",e="/impower-blogs/assets/1718672015625-YWkUlarj.png",t="/impower-blogs/assets/image1-Cx6ODMCP.png",p="/impower-blogs/assets/1718673409069-BujohJ6Y.png",h="/impower-blogs/assets/1718707718025-BpQSF-_m.png",r="/impower-blogs/assets/1718707736272-BIO9SWCT.png",k="/impower-blogs/assets/1718707804681-Bp982d9C.png",d="/impower-blogs/assets/1718707871662-BD7BawWq.png",g="/impower-blogs/assets/1718797002629-DsPvBDJS.png",o="/impower-blogs/assets/1718797230993-4_1VHPb5.png",c="/impower-blogs/assets/1718708202152-DXGYuBsF.png",m="/impower-blogs/assets/1718708454338-DvCDp6Cp.png",y="/impower-blogs/assets/20210425134508117-BtArngMK.png",v="/impower-blogs/assets/1718708500851-DspJVTQC.png",u="/impower-blogs/assets/1718708521816-DSSoSIa5.png",B="/impower-blogs/assets/1718798020769-Bea0cokC.png",C="/impower-blogs/assets/1718798073371-xdk1Wpub.png",E="/impower-blogs/assets/1718798090412-ypg4ndkA.png",b="/impower-blogs/assets/1718798108805-DVFCb29J.png",f="/impower-blogs/assets/1718708596962-6xFAF2RT.png",D="/impower-blogs/assets/68747470733-CR0PkWk_.png",A="/impower-blogs/assets/687-B8FE_7sa.png",F="/impower-blogs/assets/68747470733a-BuQpOeK0.png",J="/impower-blogs/assets/68747470733a2-CFuP_q-R.jpeg",x="/impower-blogs/assets/1718798645003-C3PSnNYW.png",S="/impower-blogs/assets/1718798664736-Bsvv5sQl.png",M="/impower-blogs/assets/image-20240319184729003-fEP45HAm.png",_="/impower-blogs/assets/image-20240322183736243-C4WvjEeK.png",j={},G=n(`<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>Jvm</span></a></h1><h2 id="从面试开始" tabindex="-1"><a class="header-anchor" href="#从面试开始"><span>从面试开始</span></a></h2><ol><li>请谈谈你对JVM 的理解(谈谈JVM的内存模型)？为啥选择JDK17?</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">性能提升</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">更好的垃圾回收器。综合评估，从 Java </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 升级到 Java </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，G1GC 平均速度提升 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">16.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，ParallelGC 为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，从 Java </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 升级到 Java </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，G1GC 平均速度提升 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">8.66</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，ParallelGC 为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">6.54</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // 最大的亮点是带来了稳定版的 ZGC 垃圾回收器，达到亚毫秒级停顿、吞吐量也比较高。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Spring</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> framework6 和 </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Spring</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Boot3 都默认使用 Java </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 作为最低版本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">JDK17</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 相对于 JDK8 和 JDK11，所有垃圾回收器的性能都有很明显的提升，特别是稳定版的 ZGC 垃圾回收器、开启方式：</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">UseZGC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">JDK14</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> 开始删除 CMS 垃圾回收器</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">JDK14 开始弃用 ParallelScavenge 和 </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">SerialOld</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> GC 的组合使用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>什么是OOM ？什么是StackOverflowError？有哪些方法分析？java 内存快照 -jar 可执行jar包:</li><li>JVM 的常用参数调优你知道哪些？</li><li>内存快照抓取和MAT分析DUMP文件知道吗？</li><li>谈谈JVM中，对类加载器你的认识？</li><li>GC类型:3种:</li><li>三大垃圾回收算法和垃圾回收器[G1、ZGC]</li></ol><h2 id="jvm简介" tabindex="-1"><a class="header-anchor" href="#jvm简介"><span>jvm简介</span></a></h2><p>JDK=JRE+工具集(java.exe、javac.exe...)</p><p>JRE=JVM+系统类库(lib:jar包)</p><p>jvm的作用:<strong>加载并执行Java字节码文件(.class)</strong></p><p>java程序特点：跨平台性</p><p><strong>解决了跨平台性</strong><br><img src="`+l+'" alt="image.png" loading="lazy"></p><h2 id="jvm架构" tabindex="-1"><a class="header-anchor" href="#jvm架构"><span>jvm架构</span></a></h2><p>jvm的整体架构如下所示：<br><img src="'+e+'" alt="image.png" loading="lazy"></p><p>详细架构:</p><p><img src="'+t+'" alt="image1.png" loading="lazy"><br><strong>在JVM中包含三部分，分别是：</strong><br><strong>功能区：类加载子系统、垃圾回收器、字节码执行引擎</strong><br><strong>线程私有区：栈(线程)、本地方法栈、程序计数器</strong><br><strong>线程共享区：方法区、堆、直接内存</strong></p><h1 id="类加载器子系统" tabindex="-1"><a class="header-anchor" href="#类加载器子系统"><span>类加载器子系统</span></a></h1><figure><img src="'+p+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="类的加载过程" tabindex="-1"><a class="header-anchor" href="#类的加载过程"><span><strong>类的加载过程</strong></span></a></h2><p>**加载阶段:**通过一个类的全限定名获取这个类所对应的二进制字节流，然后通过该二进制字节流将其加载到JVM中，并且为之创建一个Class对象</p><p><strong>连接阶段:</strong></p><p>​ **验证：**为了确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全</p><p>​ <strong>准备:</strong> 为类变量分配内存并设置初始值，使用方法区的内存</p><p>​ <strong>解析</strong>: 将常量池的符号引用替换为直接引用的过程</p><p><strong>初始化阶段:</strong> 初始化阶段才真正开始执行类中定义的 Java 程序代码。</p><p>jvm为了一个类的 &lt;\\clinit&gt;() 方法在多线程环境下能够被正常加载会对该类加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;\\clinit&gt;()方法，其它线程都会阻塞等待，直到活动线程执行 &lt;\\clinit&gt;() 方法完毕。如果在一个类的 &lt;\\clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p><h2 id="类的声明周期" tabindex="-1"><a class="header-anchor" href="#类的声明周期"><span><strong>类的声明周期</strong></span></a></h2><p>类的加载过程+使用阶段+卸载阶段</p><h2 id="初始化开始的时机" tabindex="-1"><a class="header-anchor" href="#初始化开始的时机"><span><strong>初始化开始的时机</strong></span></a></h2><p><strong>主动引用:</strong></p><ul><li>在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。</li><li>对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。</li><li>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。</li><li>虚拟机启动时，用于需要指定一个包含 <code>main()</code> 方法的主类，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li></ul><p><strong>被动引用:</strong></p><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">SubClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // value 字段在 SuperClass 中定义</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">SuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[] sca </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> SuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">ConstClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">HELLOWORLD</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="类加载器分类" tabindex="-1"><a class="header-anchor" href="#类加载器分类"><span><strong>类加载器分类</strong></span></a></h2><p>1、启动类加载器（Bootstrap class loader）</p><p>它是虚拟机的内置类加载器，通过表示为null。负责加载Java核心类库，如rt.jar中的类、只加载包名为java、javax、sun等开头的类。启动类加载器是由C++实现的，不是一个Java类。</p><p>2、扩展类加载器（Extension|Platform Class Loader）(平台类加载器)</p><p>扩展类加载器负责加载Java的扩展类库，**位于JRE的lib/ext目录下的jar包。**在 Java 9 之后，由于模块化的引入，这个类加载器已经被废弃。平台类加载器负责加载 JDK 自带的模块。<strong>这些模块通常位于 JDK 安装目录下的 jmods 文件夹中。</strong></p><p>3、应用程序类加载器（Application Class Loader）</p><p>也称为<strong>系统类加载器</strong>，它负责加载应用程序的类，即开发者自己编写的类。</p><p>4、自定义类加载器</p><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() <strong>实现了双亲委派模型的逻辑</strong>，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><figure><img src="'+h+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>上述箭头是指类加载器之间的上下级关系，而不是继承关系，它们的继承体系如下所示：<br><img src="'+r+'" alt="image.png" loading="lazy"></p><h2 id="双亲委托-派-机制" tabindex="-1"><a class="header-anchor" href="#双亲委托-派-机制"><span>双亲委托(派)机制</span></a></h2><figure><img src="'+k+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="什么是双亲委托机制" tabindex="-1"><a class="header-anchor" href="#什么是双亲委托机制"><span><strong>什么是双亲委托机制</strong></span></a></h3><p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p><h3 id="双亲委派模型的工作过程" tabindex="-1"><a class="header-anchor" href="#双亲委派模型的工作过程"><span><strong>双亲委派模型的工作过程</strong></span></a></h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载,而是返回给上级, 每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。</p><p>在 java.lang.ClassLoader 中的 <code>loadClass</code> 方法中实现该过程。</p><h3 id="为什么使用双亲委派模型" tabindex="-1"><a class="header-anchor" href="#为什么使用双亲委派模型"><span>为什么使用双亲委派模型</span></a></h3><p>1、<strong>避免重复加载</strong>：当一个类需要被加载时，首先会委派给父类加载器进行加载。如果父类加载器能够找到并加载该类，就不会再由子类加载器重复加载，避免了重复加载同一个类的问题。<br> 2、<strong>确保类的唯一性</strong>：通过双亲委派机制，类加载器在加载类时会按照一定的顺序进行查找和加载。这样可以确保同一个类在不同的类加载器中只会被加载一次，保证了类的唯一性。<br> 3、<strong>提高安全性</strong>：双亲委派机制可以防止恶意代码通过自定义类加载器来替换核心类库中的类。因为在加载核心类库时，会优先委派给启动类加载器进行加载，而启动类加载器是由JVM提供的，具有较高的安全性，这种机制防止某些核心类库被恶意篡改等。</p><h3 id="自定义类加载器打破双亲委派模型" tabindex="-1"><a class="header-anchor" href="#自定义类加载器打破双亲委派模型"><span>自定义类加载器打破双亲委派模型</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> FileSystemClassLoader</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> rootDir</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> FileSystemClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> rootDir</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rootDir</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> rootDir;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    protected</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> findClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ClassNotFoundException</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">classData</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getClassData</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(name);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (classData </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ClassNotFoundException</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> defineClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(name, classData, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">classData</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getClassData</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> className</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> classNameToPath</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(className);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            InputStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> ins</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> FileInputStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(path);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            ByteArrayOutputStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> baos</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ByteArrayOutputStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> bufferSize</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 4096</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[bufferSize];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> bytesNumRead</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ((bytesNumRead </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ins</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(buffer)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">                baos</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(buffer, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, bytesNumRead);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> baos</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">IOException</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> classNameToPath</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> className</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> rootDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">separatorChar</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">                +</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> className</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">File</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">separatorChar</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;.class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h1><figure><img src="`+d+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>线程私有区:</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享区:</p><ul><li>堆</li><li>方法区</li><li>直接内存</li></ul><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><p>属于线程私有区<br> 作用：是一块较小的内存空间，存储的是当前线程所执行的<strong>行号</strong><br> 特点：<strong>线程私有</strong>空间 ，唯一一个<strong>不会出现内存溢出</strong>的内存空间</p><h2 id="本地方法接口-本地库" tabindex="-1"><a class="header-anchor" href="#本地方法接口-本地库"><span>本地方法接口/本地库</span></a></h2><p>属于线程私有区</p><p>作用: 与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法，本地方法的实现一般都是通过c语言。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p><p>特点: <strong>只处理被native所修饰的方法</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> native</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		// 获取字节码文件对象的本地方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> native</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">					// 获取对象hashCode值的本地方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在Java虚拟机（JVM）中，本地方法接口（Native Method Interface，JNI）和本地库（Native Library）是用于与</p><p>底层系统交互的机制。</p><p>本地库是一个包含本地方法实现的动态链接库（DLL）或共享对象文件（SO）。它是使用其他编程语言编写的，</p><p>通常是为了与底层操作系统或硬件进行交互。</p><p>本地库可以通过JNI加载到JVM中，并提供给Java代码调用。</p><p>使用本地方法接口和本地库，Java程序可以利用底层系统的功能和性能优势，例如访问硬件设备、调用操作系统特</p><p>定的API、执行高性能计算等。同时，本地方法也可以用于与现有的C/C++代码进行集成，以便重用现有的代码库。</p><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h2><figure><img src="`+g+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>属于线程私有区</p><p>概述: 以栈帧（Stack Frame)为单位进行管理每个栈帧对应一个方法的执行。当一个方法被调用时，JVM会为该方法创建一个新的栈帧，并将其推入当前线程的</p><p>JVM栈顶。当方法执行完毕或者遇到异常时，栈帧会被弹出，恢复到上一个栈帧的状态</p><p>作用: 实现java的方法调用</p><p>特点:</p><ul><li><p>运行速度特别快，仅仅次于 PC 寄存器。</p></li><li><p>它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p></li></ul><h3 id="栈帧详解" tabindex="-1"><a class="header-anchor" href="#栈帧详解"><span>栈帧详解</span></a></h3><p>每个栈帧由五部分组成：</p><p>局部变量表（Local Variable Table）</p><p>操作数栈（Operand Stack）</p><p>动态链接（Dynamic Linking）</p><p>方法出口</p><p>附加信息</p><h4 id="局部变量表-local-variable-table" tabindex="-1"><a class="header-anchor" href="#局部变量表-local-variable-table"><span>局部变量表（Local Variable Table）</span></a></h4><p>作用： 存储方法参数和方法体内的局部变量：8种基本类型变量、对象引用（reference) 以及 return address 类型。</p><p>局部变量表容量大小是在编译期确定下来的。最基本的存储单元是 slot，32 位占用一个 slot，64 位类型（long 和 double）占用两个 slot。</p><h4 id="操作数栈-operand-stack" tabindex="-1"><a class="header-anchor" href="#操作数栈-operand-stack"><span>操作数栈（Operand Stack）</span></a></h4><p>作用：用于存储方法执行过程中的<strong>操作数</strong>。主要作为方法调用的中转站使用，用于存放方法执行过程中产生的<strong>中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中</strong></p><h4 id="动态链接-dynamic-linking" tabindex="-1"><a class="header-anchor" href="#动态链接-dynamic-linking"><span>动态链接（Dynamic Linking）</span></a></h4><p>动态链接是指在方法调用过程中，将<strong>符号引用（Symbolic Reference）解析为实际的方法或字段</strong>。符号引用是一种用于表示方法或字段的符号名称，它与具体的内存地址没有直接关联。而<strong>动态链接的作用就是将符号引用转换为实际的内存地址</strong>，以便正确地执行方法调用。<br> 当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。<br><img src="'+o+'" alt="" loading="lazy"></p><h4 id="方法返回地址" tabindex="-1"><a class="header-anchor" href="#方法返回地址"><span>方法返回地址</span></a></h4><p>方法返回地址存储的是调用该方法的<strong>程序计数器的值</strong>。<br> **作用：**可以知道调用完当前方法后，上一层方法接着做什么。</p><h3 id="stackoverflowerror" tabindex="-1"><a class="header-anchor" href="#stackoverflowerror"><span>StackOverflowError</span></a></h3><p>JVM栈的大小是固定的【通常为1MB】，可以通过命令行参数【<strong>-Xss</strong>】进行调整。每个线程都有自己独立的JVM栈，用于支持线程的并发执行。</p><p><strong>栈太小或者方法调用过深</strong>，都将抛出StackOverflowError异常 出现 StackOverFlowError 时，内存空间可能还有很多</p><h3 id="outofmemoryerror" tabindex="-1"><a class="header-anchor" href="#outofmemoryerror"><span>OutOfMemoryError</span></a></h3><p>如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p><h2 id="java堆" tabindex="-1"><a class="header-anchor" href="#java堆"><span>Java堆</span></a></h2><p>Java虚拟机堆是Java内存区域中一块用来存放<strong>对象</strong>实例、数组、stringtable的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】<br> 堆内存还可以继续进行细分，如下所示：<br><img src="'+c+'" alt="image.png" loading="lazy"></p><p>在默认情况下，Java虚拟机堆内存的初始大小为物理内存的1/64，并且最大可达物理内存的1/4。</p><p>新生代占整个堆内存的1/3、老年代占整个堆内存的2/3 1:2</p><p>新生代又可以细分为：伊甸园(Eden)、幸存区(from、to)，它们之间的比例默认情况下是8:1:1</p><p><strong>特点</strong>：</p><ul><li>被<strong>线程共享</strong>，因此需要考虑线程安全问题</li><li>会产生内存溢出问题</li><li>在虚拟机启动时创建</li><li>是垃圾回收的主要场所</li><li>Java 虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>关于 Survivor s0，s1 区: 复制之后有交换，谁空谁是 to</li></ul><h3 id="新生代与老年代" tabindex="-1"><a class="header-anchor" href="#新生代与老年代"><span>新生代与老年代</span></a></h3><ul><li>老年代比新生代生命周期长。</li><li>在默认情况下，Java虚拟机堆内存的初始大小为物理内存的1/64，并且最大可达物理内存的1/4。</li><li>几乎所有的 Java 对象都是在 Eden 区被 new 出来的，Eden 放不了的大对象，就直接进入老年代了。</li></ul><h3 id="对象分配过程" tabindex="-1"><a class="header-anchor" href="#对象分配过程"><span>对象分配过程</span></a></h3><ul><li>new 的对象先放在 Eden 区，大小有限制</li><li>如果创建新对象时，Eden 空间填满了，就会触发 Minor GC，将 Eden 不再被其他对象引用的对象进行销毁，再加载新的对象放到 Eden 区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区</li><li>将 Eden 中剩余的对象移到 Survivor0 区</li><li>再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区</li><li>再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推</li><li>默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置</li><li>频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集</li></ul><p><strong>为什么是15岁?</strong></p><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十</p><p>进制的 15。因此，对象的年龄被限制为 0 到 15</p><h3 id="对象分配策略" tabindex="-1"><a class="header-anchor" href="#对象分配策略"><span>对象分配策略</span></a></h3><ol><li><strong>对象优先在 Eden 分配</strong></li></ol><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><ol start="2"><li><strong>大对象直接进入老年代</strong></li></ol><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><ol start="3"><li><strong>长期存活的对象进入老年代</strong></li></ol><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1</p><p>岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><ol start="4"><li><strong>动态对象年龄判定</strong></li></ol><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年</p><p>龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等</p><p>到 MaxTenuringThreshold 中要求的年龄。</p><ol start="5"><li><strong>空间分配担保</strong></li></ol><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立</p><p>的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年</p><p>代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如</p><p>果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h3 id="minor-gc-和-full-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc-和-full-gc"><span>Minor GC 和 Full GC</span></a></h3><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h3 id="full-gc-的触发条件" tabindex="-1"><a class="header-anchor" href="#full-gc-的触发条件"><span>Full GC 的触发条件</span></a></h3><ol><li><strong>调用 System.gc()</strong></li></ol><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><ol start="2"><li><strong>老年代空间不足</strong></li></ol><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参</p><p>数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold</p><p>调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><ol start="3"><li><strong>空间分配担保失败</strong></li></ol><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><ol start="4"><li><strong>JDK 1.7 及以前的永久代空间不足</strong></li></ol><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、</p><p>静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下</p><p>也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><ol start="5"><li><strong>Concurrent Mode Failure</strong></li></ol><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致</p><p>暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h3 id="堆内存大小设定" tabindex="-1"><a class="header-anchor" href="#堆内存大小设定"><span>堆内存大小设定</span></a></h3><p>-XX:NewRatio</p><p>设置老年代和新生代的初始比例。例如，-XX:NewRatio=2表示新生代占堆内存的1/3，老年代占堆内存的2/3。</p><p>-XX:SurvivorRatio</p><p>设置Eden区和Survivor区的初始比例。例如，-XX:SurvivorRatio=8表示Eden区占新生代的8/10，每个Survivor区占新生代的1/10。</p><p>-Xms</p><p>设置堆的初始大小。例如，-Xms512m表示将堆的初始大小设置为512MB。</p><p>-Xmx</p><p>设置堆的最大大小。例如，-Xmx1024m表示将堆的最大大小设置为1GB。</p><p>-Xmn</p><p>设置新生代的大小。例如，-Xmn256m表示将新生代的大小设置为256MB。</p><h2 id="方法区-元空间" tabindex="-1"><a class="header-anchor" href="#方法区-元空间"><span>方法区(元空间)</span></a></h2><p>方法区是被所有<strong>线程共享</strong>。</p><p>方法区主要包含以下几个重要的组成部分：</p><p>1、类信息：方法区存储了加载的类的结构信息，包括类的名称、父类、接口、字段、方法等。这些信息在类加载</p><p>过程中被加载到方法区，并且在运行时被使用。</p><p>2、运行时常量池：每个类都有一个运行时常量池，它是方法区的一部分。运行时常量池用于存储编译期生成的各</p><p>种字面量和符号引用。例如，字符串常量、类和方法的符号引用等都存储在运行时常量池中。</p><p>3、即时编译器编译后的代码：当JVM将某段热点代码（HotSpot）识别出来后，会将其编译为机器码以提高执行</p><p>效率。这些编译后的代码被存储在方法区中。<br><img src="'+m+'" alt="image.png" loading="lazy"></p><p>变化的原因：</p><figure><img src="'+y+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息、运行时常量池</p><p>这些信息不能被轻易回收)</p><p>2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低)</p><h3 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池"><span>运行时常量池</span></a></h3><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h3 id="字符串常量池" tabindex="-1"><a class="header-anchor" href="#字符串常量池"><span>字符串常量池</span></a></h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存"><span>直接内存</span></a></h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h1 id="执行引擎" tabindex="-1"><a class="header-anchor" href="#执行引擎"><span>执行引擎</span></a></h1><p><img src="'+v+'" alt="image.png" loading="lazy"><br> 执行引擎主要包含以下几个重要的组成部分：</p><p>1、<strong>解释器（Interpreter）</strong>：解释器逐条解释字节码指令，并将其转换为对应的机器码进行执行。解释器的优点</p><p>是实现简单、快速启动和适应性强，但由于每次执行都需要解释字节码，因此执行效率相对较低。</p><p>2、<strong>即时编译器（Just-In-Time Compiler，JIT）</strong>：即时编译器将热点代码（HotSpot）从字节码直接编译成机器</p><p>码，以提高执行效率。热点代码通常是经过多次执行的代码块，即被频繁调用的方法或循环等。即时编译器可以根</p><p>据运行时的情况进行优化，例如内联展开、方法内联、去除无用代码等。JVM中常用的即时编译器有C1（Client</p><p>Compiler）和C2（Server Compiler）。</p><p>3、**垃圾回收器（Garbage Collector）：**垃圾回收器负责自动回收不再使用的对象，并释放其占用的内存空间。执</p><p>行引擎与垃圾回收器紧密合作，当执行引擎发现某个对象不再被引用时，会通知垃圾回收器进行回收。垃圾回收器</p><p>的工作涉及到堆内存的分配和释放，以及对象的标记、清除等操作。</p><figure><img src="'+u+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="★如何判断对象是否死亡" tabindex="-1"><a class="header-anchor" href="#★如何判断对象是否死亡"><span><strong>★如何判断对象是否死亡</strong></span></a></h2><p>要进行垃圾回收，那么首先需要找出垃圾，如果判断一个对象是否为垃圾呢?</p><p>两种算法：</p><p>1、引用计数法</p><p>2、可达性分析算法</p><h3 id="引用计数法-reference-counting" tabindex="-1"><a class="header-anchor" href="#引用计数法-reference-counting"><span>引用计数法(Reference-Counting)</span></a></h3><p>引用计数算法是通过判断对象的<strong>引用数量</strong>来决定对象是否可以被回收。</p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任</p><p>何时刻计数器为0的对象就是不可能再被使用的。</p><p>优点：</p><ul><li>简单，高效，现在的objective-c、python等用的就是这种算法。</li></ul><p>缺点：</p><ul><li>引用和去引用伴随着加减算法，影响性能</li><li>很难处理循环引用，相互引用的两个对象则无法释放。<br> 因此，目前主流的Java虚拟机都摒弃掉了这种算法</li></ul><h3 id="可达性分析算法-jvm中默认使用" tabindex="-1"><a class="header-anchor" href="#可达性分析算法-jvm中默认使用"><span>可达性分析算法(JVM中默认使用)</span></a></h3><p>这个算法的基本思想，就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走</p><p>过的路径称为<strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连的话，则证明，此对象是不可用的。(类似于</p><p>葡萄串)；<br><img src="'+B+'" alt="image.png" loading="lazy"><br> 在Java语言中，可以作为GC Roots的对象包括下面几种：</p><p>1、虚拟机栈（栈帧中的本地变量表）中的引用对象 ==&gt; 正在运行的方法中的参数、局部变量等</p><p>2、方法区中的常量引用的对象 ==&gt; 运行时常量池中的对象，例如程序中需要使用的类的类类型对象</p><p>3、本地方法栈中JNI（Native方法）的引用对象 ==&gt; 正在运行的本地方法</p><p>4、Java虚拟机的内部引用 ==&gt; 基本数据类型对应的Class对象，常驻异常对象（空指针、OOM等)，系统类加载器</p><p>5、被同步锁synchronize持有的对象。</p><h3 id="如何判断一个常量是废弃常量" tabindex="-1"><a class="header-anchor" href="#如何判断一个常量是废弃常量"><span>如何判断一个常量是废弃常量?</span></a></h3><p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类" tabindex="-1"><a class="header-anchor" href="#如何判断一个类是无用的类"><span>如何判断一个类是无用的类?</span></a></h3><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必</p><p>然被回收</p><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><h3 id="标记清除-mark-sweep" tabindex="-1"><a class="header-anchor" href="#标记清除-mark-sweep"><span>标记清除(Mark-Sweep)</span></a></h3><p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br><img src="'+C+'" alt="image.png" loading="lazy"><br> 优点：速度比较快<br> 缺点：会产生内存碎片，碎片过多，仍会使得连续空间少</p><h3 id="标记整理-mark-compact" tabindex="-1"><a class="header-anchor" href="#标记整理-mark-compact"><span>标记整理(Mark-Compact)</span></a></h3><p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低<br><img src="'+E+'" alt="image.png" loading="lazy"><br> 优点：无内存碎片<br> 缺点：效率较低</p><h3 id="复制算法-copying" tabindex="-1"><a class="header-anchor" href="#复制算法-copying"><span>复制算法(Copying)</span></a></h3><p>执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；<br><img src="'+b+'" alt="image.png" loading="lazy"><br> 优点：无内存碎片<br> 缺点：占用空间多<br> 注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；</p><h3 id="分代回收-generational-collection" tabindex="-1"><a class="header-anchor" href="#分代回收-generational-collection"><span>分代回收(Generational-Collection)</span></a></h3><p>概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年</p><p>代的特点采用最合适的算法；</p><p>新生代对象的存活的时间都比较短，因此使用的是【复制算法】；</p><p>而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；</p><h2 id="四种引用类型" tabindex="-1"><a class="header-anchor" href="#四种引用类型"><span>四种引用类型</span></a></h2><h3 id="强引用" tabindex="-1"><a class="header-anchor" href="#强引用"><span>强引用</span></a></h3><p>Java中默认声明的就是强引用<br><strong>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。</strong></p><h3 id="软引用" tabindex="-1"><a class="header-anchor" href="#软引用"><span>软引用</span></a></h3><p><strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象</strong><br> 在 JDK1.2 之后，用java.lang.ref.<strong>SoftReference</strong>类来表示软引用。</p><h3 id="弱引用" tabindex="-1"><a class="header-anchor" href="#弱引用"><span>弱引用</span></a></h3><p><strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。<br> 在 JDK1.2之后,用java.lang.ref.<strong>WeakReference</strong>来表示弱引用。</p><h3 id="虚引用" tabindex="-1"><a class="header-anchor" href="#虚引用"><span>虚引用</span></a></h3><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，</p><h2 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器"><span>垃圾收集器</span></a></h2><figure><img src="'+f+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h3 id="cms-收集器" tabindex="-1"><a class="header-anchor" href="#cms-收集器"><span>CMS 收集器</span></a></h3><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><figure><img src="'+D+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3 id="g1-收集器" tabindex="-1"><a class="header-anchor" href="#g1-收集器"><span>G1 收集器</span></a></h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><figure><img src="'+A+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><figure><img src="'+F+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><figure><img src="'+J+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h1 id="线上问题定位" tabindex="-1"><a class="header-anchor" href="#线上问题定位"><span>线上问题定位</span></a></h1><p>不同的问题【接口报错，RT超时、CPU飙高、OOM...】排查方案是一不一样的。</p><p>排查问题方式：直接排查<strong>项目的运行日志</strong>，tomcat的logs，找到运行日志或者项目目录logs文件夹，去分析运行</p><p>日志，找到问题点，进行问题定位和分析，最后解决，更新源码，运维部署迭代。</p><p>如果是分布式系统关于日志的采集可能需要有一套完整的日志采集系统：Spring Boot Admin、ELK</p><p>没有报错、程序卡死这种问题参数的主要原因可能是CPU飙升、内存飙升、死锁等。</p><h2 id="cpu飙升问题排查" tabindex="-1"><a class="header-anchor" href="#cpu飙升问题排查"><span>CPU飙升问题排查</span></a></h2><p>具体步骤如下所示：<br> 1、通过top查看系统各种资源的占用情况，看看CPU占用是否过高</p><p>2、通过ps -ef | grep java查询指定的进程id</p><p>3、通过top -H -p pid查看指定进程中的线程信息(一个进程中有多个线程哦)</p><p><img src="'+x+'" alt="image.png" loading="lazy"><br> 4、将线程的id的十进制数据转换成十六进制：printf &quot;%x&quot; tid</p><p>5、通过jstack -l pid查询进行中的线程nid(native thread id):</p><figure><img src="'+S+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="死锁问题排查" tabindex="-1"><a class="header-anchor" href="#死锁问题排查"><span>死锁问题排查</span></a></h2><p><strong>死锁</strong>：线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执</p><h2 id="oom异常" tabindex="-1"><a class="header-anchor" href="#oom异常"><span>OOM异常</span></a></h2><h1 id="内存分析图" tabindex="-1"><a class="header-anchor" href="#内存分析图"><span>内存分析图</span></a></h1><h2 id="两个数组对象的内存图" tabindex="-1"><a class="header-anchor" href="#两个数组对象的内存图"><span>两个数组对象的内存图</span></a></h2><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="两个对象的内存图" tabindex="-1"><a class="header-anchor" href="#两个对象的内存图"><span><strong>两个对象的内存图</strong></span></a></h2><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="实例变量的内存分析" tabindex="-1"><a class="header-anchor" href="#实例变量的内存分析"><span>实例变量的内存分析</span></a></h2>',310),w=[G];function O(R,V){return a(),s("div",null,w)}const T=i(j,[["render",O],["__file","05.Jvm.html.vue"]]),X=JSON.parse('{"path":"/backend/05.Jvm.html","title":"Jvm","lang":"zh-CN","frontmatter":{"description":"Jvm 从面试开始 请谈谈你对JVM 的理解(谈谈JVM的内存模型)？为啥选择JDK17? 什么是OOM ？什么是StackOverflowError？有哪些方法分析？java 内存快照 -jar 可执行jar包: JVM 的常用参数调优你知道哪些？ 内存快照抓取和MAT分析DUMP文件知道吗？ 谈谈JVM中，对类加载器你的认识？ GC类型:3种: 三...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/impower-blogs/backend/05.Jvm.html"}],["meta",{"property":"og:site_name","content":"impower"}],["meta",{"property":"og:title","content":"Jvm"}],["meta",{"property":"og:description","content":"Jvm 从面试开始 请谈谈你对JVM 的理解(谈谈JVM的内存模型)？为啥选择JDK17? 什么是OOM ？什么是StackOverflowError？有哪些方法分析？java 内存快照 -jar 可执行jar包: JVM 的常用参数调优你知道哪些？ 内存快照抓取和MAT分析DUMP文件知道吗？ 谈谈JVM中，对类加载器你的认识？ GC类型:3种: 三..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-21T07:20:21.000Z"}],["meta",{"property":"article:author","content":"luke.lewis"}],["meta",{"property":"article:modified_time","content":"2024-07-21T07:20:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Jvm\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-21T07:20:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luke.lewis\\",\\"url\\":\\"https://github.com/d3Lap1ace\\",\\"email\\":\\"aegonk@163.com\\"}]}"]]},"headers":[{"level":2,"title":"从面试开始","slug":"从面试开始","link":"#从面试开始","children":[]},{"level":2,"title":"jvm简介","slug":"jvm简介","link":"#jvm简介","children":[]},{"level":2,"title":"jvm架构","slug":"jvm架构","link":"#jvm架构","children":[]},{"level":2,"title":"类的加载过程","slug":"类的加载过程","link":"#类的加载过程","children":[]},{"level":2,"title":"类的声明周期","slug":"类的声明周期","link":"#类的声明周期","children":[]},{"level":2,"title":"初始化开始的时机","slug":"初始化开始的时机","link":"#初始化开始的时机","children":[]},{"level":2,"title":"类加载器分类","slug":"类加载器分类","link":"#类加载器分类","children":[]},{"level":2,"title":"双亲委托(派)机制","slug":"双亲委托-派-机制","link":"#双亲委托-派-机制","children":[{"level":3,"title":"什么是双亲委托机制","slug":"什么是双亲委托机制","link":"#什么是双亲委托机制","children":[]},{"level":3,"title":"双亲委派模型的工作过程","slug":"双亲委派模型的工作过程","link":"#双亲委派模型的工作过程","children":[]},{"level":3,"title":"为什么使用双亲委派模型","slug":"为什么使用双亲委派模型","link":"#为什么使用双亲委派模型","children":[]},{"level":3,"title":"自定义类加载器打破双亲委派模型","slug":"自定义类加载器打破双亲委派模型","link":"#自定义类加载器打破双亲委派模型","children":[]}]},{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"本地方法接口/本地库","slug":"本地方法接口-本地库","link":"#本地方法接口-本地库","children":[]},{"level":2,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[{"level":3,"title":"栈帧详解","slug":"栈帧详解","link":"#栈帧详解","children":[]},{"level":3,"title":"StackOverflowError","slug":"stackoverflowerror","link":"#stackoverflowerror","children":[]},{"level":3,"title":"OutOfMemoryError","slug":"outofmemoryerror","link":"#outofmemoryerror","children":[]}]},{"level":2,"title":"Java堆","slug":"java堆","link":"#java堆","children":[{"level":3,"title":"新生代与老年代","slug":"新生代与老年代","link":"#新生代与老年代","children":[]},{"level":3,"title":"对象分配过程","slug":"对象分配过程","link":"#对象分配过程","children":[]},{"level":3,"title":"对象分配策略","slug":"对象分配策略","link":"#对象分配策略","children":[]},{"level":3,"title":"Minor GC 和 Full GC","slug":"minor-gc-和-full-gc","link":"#minor-gc-和-full-gc","children":[]},{"level":3,"title":"Full GC 的触发条件","slug":"full-gc-的触发条件","link":"#full-gc-的触发条件","children":[]},{"level":3,"title":"堆内存大小设定","slug":"堆内存大小设定","link":"#堆内存大小设定","children":[]}]},{"level":2,"title":"方法区(元空间)","slug":"方法区-元空间","link":"#方法区-元空间","children":[{"level":3,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]},{"level":3,"title":"字符串常量池","slug":"字符串常量池","link":"#字符串常量池","children":[]},{"level":3,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]}]},{"level":2,"title":"★如何判断对象是否死亡","slug":"★如何判断对象是否死亡","link":"#★如何判断对象是否死亡","children":[{"level":3,"title":"引用计数法(Reference-Counting)","slug":"引用计数法-reference-counting","link":"#引用计数法-reference-counting","children":[]},{"level":3,"title":"可达性分析算法(JVM中默认使用)","slug":"可达性分析算法-jvm中默认使用","link":"#可达性分析算法-jvm中默认使用","children":[]},{"level":3,"title":"如何判断一个常量是废弃常量?","slug":"如何判断一个常量是废弃常量","link":"#如何判断一个常量是废弃常量","children":[]},{"level":3,"title":"如何判断一个类是无用的类?","slug":"如何判断一个类是无用的类","link":"#如何判断一个类是无用的类","children":[]}]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"标记清除(Mark-Sweep)","slug":"标记清除-mark-sweep","link":"#标记清除-mark-sweep","children":[]},{"level":3,"title":"标记整理(Mark-Compact)","slug":"标记整理-mark-compact","link":"#标记整理-mark-compact","children":[]},{"level":3,"title":"复制算法(Copying)","slug":"复制算法-copying","link":"#复制算法-copying","children":[]},{"level":3,"title":"分代回收(Generational-Collection)","slug":"分代回收-generational-collection","link":"#分代回收-generational-collection","children":[]}]},{"level":2,"title":"四种引用类型","slug":"四种引用类型","link":"#四种引用类型","children":[{"level":3,"title":"强引用","slug":"强引用","link":"#强引用","children":[]},{"level":3,"title":"软引用","slug":"软引用","link":"#软引用","children":[]},{"level":3,"title":"弱引用","slug":"弱引用","link":"#弱引用","children":[]},{"level":3,"title":"虚引用","slug":"虚引用","link":"#虚引用","children":[]}]},{"level":2,"title":"垃圾收集器","slug":"垃圾收集器","link":"#垃圾收集器","children":[{"level":3,"title":"CMS 收集器","slug":"cms-收集器","link":"#cms-收集器","children":[]},{"level":3,"title":"G1 收集器","slug":"g1-收集器","link":"#g1-收集器","children":[]}]},{"level":2,"title":"CPU飙升问题排查","slug":"cpu飙升问题排查","link":"#cpu飙升问题排查","children":[]},{"level":2,"title":"死锁问题排查","slug":"死锁问题排查","link":"#死锁问题排查","children":[]},{"level":2,"title":"OOM异常","slug":"oom异常","link":"#oom异常","children":[]},{"level":2,"title":"两个数组对象的内存图","slug":"两个数组对象的内存图","link":"#两个数组对象的内存图","children":[]},{"level":2,"title":"两个对象的内存图","slug":"两个对象的内存图","link":"#两个对象的内存图","children":[]},{"level":2,"title":"实例变量的内存分析","slug":"实例变量的内存分析","link":"#实例变量的内存分析","children":[]}],"git":{"createdTime":1720960541000,"updatedTime":1721546421000,"contributors":[{"name":"d3lap1ace L.Lewis","email":"ap1cem@163.com","commits":3}]},"readingTime":{"minutes":31.02,"words":9307},"filePathRelative":"backend/05.Jvm.md","localizedDate":"2024年7月14日","autoDesc":true}');export{T as comp,X as data};
